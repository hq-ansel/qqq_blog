[{"content":"前提条件 输入与隐藏状态\n输入序列 $x$ 的形状为 $(batch, len)$ 。 第 $i$ 层的输入激活值为 $hiddenstate_{i-1}$ ，形状为 $(batch, len, hiddensize)$ 。 第 $i$ 层的输出为 $hiddenstate_i$ ，形状同样为 $(batch, len, hiddensize)$ 。 单个 Token 的处理\n对于序列中的第 $j$ 个 token $x_j$ ，其输入为 $hiddenstate_{i-1,j}$ ，输出为 $hiddenstate_{i,j}$ ，形状为 $(batch，hiddensize)$ 。 计算关系为： $$ hiddenstate_{i,j} = f(hiddenstate_{i-1,j}) $$ 函数 $f$ 的定义为： $$ f(x) = (x + {atten}(x)) + {mlp}(x + {atten}(x)) $$ 其中， ${mlp}$ 和加法操作在序列长度（ $len$ ）这一维度上是独立的，即对于 $z = x \\ {op} \\ y$ ，有 $z_{k,:}$ 仅依赖于 $x_{k,:}$ 和 $y_{k,:}$ ，与 $m \\neq k$ 时的 $x_m$ 和 $y_m$ 无关。 注意力机制的区别\nCausal Attention（自回归注意力）的省略版本： $$ ({Q} \\times {K})_{k,:} = {atten}(x_k, x_{:k}) $$即，第 $k$ 个位置的查询仅与当前及之前的位置相关。\nBi-directional Attention（双向注意力）： $$ ({Q} \\times {K})_{k,:}^t = {atten}(x_k^t, x_{:}^t) $$其中， $t$ 表示时间步，第 $k$ 个token的查询与当前时间步的所有token相关。\n推论 1. Causal Attention 的推理阶段 依赖关系： 对于 $hiddenstate_{i,j}$ ，其依赖于 $hiddenstate_{i-1,j}$ 和 $hiddenstate_{i-1,j-1}, \\ldots, hiddenstate_{i-1,0}$ 。且不同时间步下 $hiddenstate_{i,j}^t=hiddenstate_{i,j}^{t+1}$ 最终预测结果 $y_j$ 是 $hiddenstate_{last,j}$ 的函数。 KV-Cache 的应用： 预计算：由于 $K_{i,j}$ 仅依赖于 $x_{:j}$ 即 $K_{i,j}=func(hiddenstate_{i-1,:j})$ ，且与时间步 $t$ 无关，即： $$ K_{i,j} = K_{i,j}^t, \\quad V_{i,j} = V_{i,j}^t $$因此，可以在推理前预先计算并缓存 $K$ 和 $V$ 。\n计算需求：在推理时，仅需使用 $x_j$ （形状为 $(batch, 1, hiddensize)$ ）、 $K_{:,j}$ 和 $V_{:,j}$ （形状为 $(batch, len, hiddensize) \\times {layernum}$ ）进行计算。 结论：由于 $K$ 和 $V$ 不随时间步变化，可以缓存计算，Causal Attention 可以有效利用 KV-Cache 进行加速推理。 2. Bi-directional Attention 的推理阶段 依赖关系： 最终预测结果 $y_j$ 依赖于 $hiddenstate_{last,j}$ 。 $hiddenstate_{i,j}^t$ 依赖于 $K_{:}^t$ ，即当前时间步的所有键值。 KV-Cache 的限制： 在 Bi-directional Attention 中， $K_{:}^t$ 依赖于当前时间步 $t$ 的所有输入，因此不同时间步之间的 $K$ 和 $V$ 是相互关联的。 这种依赖关系导致无法像在 Causal Attention 中那样独立缓存 $K$ 和 $V$ ，因为每个时间步的计算都可能影响其他时间步的 $K$ 和 $V$ 。 ","permalink":"http://119.91.218.8/zh/posts/kv-cache%E8%AE%A8%E8%AE%BA/","summary":"\u003ch3 id=\"前提条件\"\u003e前提条件\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e输入与隐藏状态\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e输入序列  $x$  的形状为  $(batch, len)$ 。\u003c/li\u003e\n\u003cli\u003e第  $i$  层的输入激活值为  $hiddenstate_{i-1}$ ，形状为  $(batch, len, hiddensize)$ 。\u003c/li\u003e\n\u003cli\u003e第  $i$  层的输出为  $hiddenstate_i$ ，形状同样为  $(batch, len, hiddensize)$ 。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e单个 Token 的处理\u003c/strong\u003e\u003c/p\u003e","title":"kv-cache讨论"},{"content":"这周由于项目历史遗留问题，会碰见访问端口被写死的情况，出于偷懒不想修改大批量的代码，于是了解了一下socat这个工具； 需要了解socat，首先会了解与其功能相似的netcat\nnetcat Netcat（通常缩写为 nc）是一个功能强大的网络工具，广泛用于网络调试和诊断。它的设计初衷是提供一种简单而灵活的方式来创建TCP或UDP连接，进行数据传输和测试。\n常见用法： 作为客户端：\n1 nc [hostname] [port] 这条命令用于连接到指定主机和端口，类似于telnet的功能。\n作为服务器监听端口：\n1 nc -l -p [port] 这将启动一个监听指定端口的服务器，等待客户端连接。\n端口扫描：\n1 nc -zv [hostname] [start_port]-[end_port] -z 表示扫描端口而不建立连接，-v 则是输出详细信息。\n数据传输： 发送文件：\n1 nc -w 3 [destination] [port] \u0026lt; [file] 接收文件：\n1 nc -l -p [port] \u0026gt; [file] Netcat 可以实现简单的 端口转发 功能，尽管它并不像一些专业的端口转发工具（比如 socat 或 iptables）那样功能强大。Netcat 的端口转发功能通常用于简单的场景，比如将流量从一个端口转发到另一个端口，或者将流量从一台机器转发到另一台机器。\nNetcat 实现端口转发 1. 将本地端口流量转发到远程主机 如果你想将本地端口的流量转发到远程主机上的某个端口，可以使用以下命令：\n1 nc -l -p [本地端口] | nc [远程主机] [远程端口] 例如，将本地的 8080 端口的流量转发到远程机器的 80 端口：\n1 nc -l -p 8080 | nc example.com 80 解释：\n-l：表示 Netcat 在本地监听指定的端口（这里是 8080）。 |：管道符，用于将输入数据从一个命令传递给另一个命令。 nc example.com 80：连接到远程主机 example.com 的 80 端口，并转发接收到的流量。 这种方式是通过管道将数据从本地端口直接转发到远程端口，但它并没有持久化的连接管理功能，适合用于临时、简单的流量转发。\n2. 双向端口转发 如果你需要双向转发，可以使用 nc 配合 \u0026amp; 来启动两个 nc 实例，这样可以同时进行双向数据传输：\n1 2 nc -l -p [本地端口] -c \u0026#39;nc [远程主机] [远程端口]\u0026#39; \u0026amp; nc [远程主机] [远程端口] -c \u0026#39;nc -l -p [本地端口]\u0026#39; 这样，每当一方有数据发送时，它会通过另一个端口将数据转发回去，保证了双向通信。\n3. UDP端口转发 Netcat 也支持 UDP 协议的端口转发。要转发 UDP 流量，可以在命令中指定 -u 选项：\n1 nc -lu [本地端口] | nc -u [远程主机] [远程端口] 例如，将本地的 UDP 12345 端口流量转发到远程的 UDP 54321 端口：\n1 nc -lu 12345 | nc -u example.com 54321 socat Socat（SOcket CAT）是一个功能强大的网络工具，类似于 Netcat，但比 Netcat 更加灵活和多功能。Socat 可以在不同的网络协议、设备、文件描述符之间进行双向数据传输。它支持 TCP、UDP、Unix 套接字、串口、文件、管道等多种类型的流量转发，广泛应用于网络调试、故障排查、端口转发、网络代理等任务。\n1. 基本功能 Socat 可以将数据从一个端口、套接字、设备或文件传输到另一个端口、套接字、设备或文件。通过配置不同的协议和目标，Socat 具有非常强的灵活性。它不仅仅是一个端口转发工具，还可以用于跨协议数据流的桥接。\n2. 常见用法 Socat 的语法是基于两端连接的，它会将一个端口的输入流转发到另一个端口。常见的命令结构如下：\n1 socat [选项] \u0026lt;源端口/地址/设备\u0026gt; \u0026lt;目标端口/地址/设备\u0026gt; 例子 1：TCP 端口转发 将本地的 8080 端口流量转发到远程服务器的 80 端口：\n1 socat TCP-LISTEN:8080,fork TCP:example.com:80 TCP-LISTEN:8080: 在本地监听 8080 端口。 fork: 每次接收到一个连接时，都派生一个新进程进行处理，支持多个并发连接。 TCP:example.com:80: 将流量转发到远程 example.com 的 80 端口。 例子 2：UDP 转发 将本地的 12345 端口的 UDP 流量转发到远程的 54321 端口：\n1 socat UDP-LISTEN:12345,fork UDP:example.com:54321 例子 3：使用 UNIX 域套接字转发 将一个 UNIX 域套接字的流量转发到 TCP 端口：\n1 socat UNIX-LISTEN:/tmp/socket,fork TCP:example.com:80 UNIX-LISTEN:/tmp/socket: 在本地监听 UNIX 套接字文件 /tmp/socket。 TCP:example.com:80: 将接收到的数据转发到远程 example.com 的 80 端口。 例子 4：串口转发 将串口（如 /dev/ttyS0）的数据转发到 TCP 端口：\n1 socat TCP-LISTEN:8080,fork OPEN:/dev/ttyS0,raw,echo=0 OPEN:/dev/ttyS0: 打开串口设备 /dev/ttyS0。 raw,echo=0: 串口数据的设置，raw 模式和关闭回显。 TCP-LISTEN:8080: 在本地监听 8080 端口，转发串口数据。 3. Socat 的高级功能 Socat 远不止于基本的端口转发，它还支持一些复杂的高级功能，使其在各种网络和设备场景中都非常有用：\n1. 加密支持（SSL/TLS） Socat 支持通过 SSL/TLS 进行加密数据传输，可以在转发的过程中对数据进行加密。\n1 socat OPENSSL-LISTEN:443,reuseaddr,fork,cert=server-cert.pem,key=server-key.pem TCP:example.com:80 OPENSSL-LISTEN:443: 在本地的 443 端口上启用 SSL/TLS 监听。 reuseaddr: 允许重新使用地址。 cert=server-cert.pem,key=server-key.pem: 指定 SSL/TLS 证书和私钥文件。 2. 文件和管道转发 Socat 可以将文件或命名管道的数据转发到网络端口，或者反向操作：\n1 socat FILE:/tmp/myfile TCP:example.com:80 将本地的文件 /tmp/myfile 内容通过 TCP 发送到 example.com:80 端口。 3. UNIX 域套接字支持 Socat 支持 UNIX 域套接字，可以将本地进程间通信的数据转发到网络端口，或者实现跨机器的 UNIX 域套接字通信。\n1 socat UNIX-LISTEN:/tmp/socket,fork TCP:example.com:8080 4. 多协议支持 Socat 支持多种协议的转发，包括但不限于：\nTCP 和 UDP（支持监听、连接和转发） UNIX 域套接字（用于本地进程间通信） SSL/TLS 加密连接 串口设备（如 /dev/ttyS0，用于串行通信） 文件描述符（用于文件流、命名管道等） 5. 双向转发 Socat 可以在连接的两端之间进行双向数据流的传输。例如：\n1 socat TCP-LISTEN:8080,fork SYSTEM:\u0026#39;echo hello\u0026#39; 该命令在每次客户端连接时执行 echo hello 并将输出返回给客户端。\n4. 与其他工具的比较 与 Netcat 比较：\n功能更强大：Socat 支持更多协议和更多的传输模式，如串口、SSL/TLS、UNIX 套接字等。 更复杂的配置：Socat 提供了更多配置选项，可以实现更复杂的流量转发和协议转换。 端口转发的高级功能：除了基础的端口转发，Socat 可以通过 fork、reuseaddr 等选项支持并发连接、重用地址等高级功能。 与 iptables 比较：\n灵活性：Socat 更适合进行临时、实验性的网络配置，而 iptables 是更适合进行长期、生产级的端口转发和防火墙配置。 协议支持：iptables 主要处理 IP 数据包过滤和转发，而 Socat 支持更多的应用层协议，能够在多种不同的协议和设备间进行转发。 ","permalink":"http://119.91.218.8/zh/posts/netcat%E4%B8%8Esocat/","summary":"\u003cp\u003e这周由于项目历史遗留问题，会碰见访问端口被写死的情况，出于偷懒不想修改大批量的代码，于是了解了一下socat这个工具；\n需要了解socat，首先会了解与其功能相似的netcat\u003c/p\u003e","title":"netcat与socat"},{"content":"函数对象（Function Objects）、Lambda 表达式 和 类的成员函数 是 C++ 中调用函数行为的三种实现方式，它们在语法、用途和底层实现上有所不同。\n1. 函数对象（Function Objects） 定义：函数对象是一个定义了 operator() 的类或结构体实例，可以像普通函数一样调用。\n示例： 1 2 3 4 5 struct MyFunctionObject { int operator()(int x) const { return x * x; } }; 使用：\n1 2 MyFunctionObject obj; int result = obj(5); // 调用 operator() 底层实现 本质是一个类或结构体，通过重载 operator() 实现。 编译器会将函数对象的调用解析为对 operator() 的直接调用。 因为函数对象是类实例，所以可以在内部保存状态（成员变量）。 特点：\n有状态：可以通过成员变量在对象中存储状态。 灵活性高：可以自定义更多逻辑、配置。 效率高：可以被内联优化，减少调用开销。 2. Lambda 表达式 定义：Lambda 是一种匿名函数，可以捕获外部作用域的变量，并立即调用或传递。\n示例： 1 2 auto lambda = [](int x) { return x * x; }; int result = lambda(5); 底层实现 Lambda 是一个编译器生成的匿名类，其行为类似于函数对象。 编译器为每个 Lambda 生成一个唯一的类，类中定义了 operator()。 如果 Lambda 捕获了变量，这些变量会被存储为该类的成员变量。 例如：\n1 2 int a = 10; auto lambda = [a](int x) { return x + a; }; // 捕获 a 等价于：\n1 2 3 4 5 6 7 8 class AnonymousLambda { int a; // 捕获变量 public: AnonymousLambda(int a) : a(a) {} int operator()(int x) const { return x + a; } }; 特点：\n无状态或有状态：根据捕获列表决定是否存储状态。 灵活性高：简化代码，常用于临时逻辑。 可内联：与函数对象类似，编译器可以内联优化。 3. 类的成员函数 定义：类的成员函数是定义在类中的函数，可以访问类的成员变量和方法。\n示例： 1 2 3 4 class MyClass { public: int square(int x) { return x * x; } }; 使用：\n1 2 MyClass obj; int result = obj.square(5); 底层实现 成员函数本质上是一个普通函数，但带有隐式的 this 指针。 在调用成员函数时，编译器会传递当前对象的地址 this，以便访问类的成员变量和其他方法。 例如：\n1 2 3 4 5 6 7 class MyClass { int a; public: void print() { std::cout \u0026lt;\u0026lt; a; } }; 底层实现等价于：\n1 2 3 void MyClass::print(MyClass* this) { std::cout \u0026lt;\u0026lt; this-\u0026gt;a; } 特点：\n绑定到对象：必须通过对象或指针调用。 有状态：依赖对象的成员变量和方法。 效率相对较高：调用成本仅增加一个 this 指针。 对比总结 特性 函数对象 Lambda 表达式 类成员函数 底层实现 重载 operator() 的类 编译器生成匿名类，重载 operator() 普通函数，隐式传递 this 指针 状态管理 可以有状态（通过成员变量） 捕获外部变量决定是否有状态 依赖类的成员变量和 this 指针 调用方式 类实例调用 () 匿名对象调用 () 必须通过类对象调用 效率 高（可内联优化） 高（可内联优化） 高（普通函数调用 + this） 灵活性 高 更高，适合临时定义 依赖类，灵活性较低 适用场景 函数对象：\n适合需要反复调用且逻辑较复杂的场景。 适用于存储状态的情况下（如计数器、配置参数）。 Lambda 表达式：\n适合临时的、一次性使用的函数逻辑。 捕获外部变量时非常方便，代码更简洁。 类成员函数：\n适合与类绑定的逻辑，依赖类的成员变量或方法。 通常用于面向对象设计中的方法。 代码示例对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;algorithm\u0026gt; // 函数对象 struct FunctionObject { int operator()(int x) const { return x * x; } }; // Lambda auto lambda = [](int x) { return x * x; }; // 类成员函数 class MyClass { public: int square(int x) const { return x * x; } }; int main() { std::vector\u0026lt;int\u0026gt; nums = {1, 2, 3, 4}; // 函数对象 FunctionObject funcObj; std::transform(nums.begin(), nums.end(), nums.begin(), funcObj); // Lambda 表达式 std::transform(nums.begin(), nums.end(), nums.begin(), lambda); // 类成员函数 MyClass obj; std::transform(nums.begin(), nums.end(), nums.begin(), [\u0026amp;](int x) { return obj.square(x); }); for (int n : nums) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } return 0; } 总结 底层实现上，函数对象和 Lambda 表达式非常相似，Lambda 本质上是一个匿名的函数对象。 类成员函数的底层实现则依赖 this 指针，绑定到特定对象。 三者的选择取决于使用场景和代码需求，Lambda 表达式在现代 C++ 中更常用，特别是在临时逻辑场景下。 ","permalink":"http://119.91.218.8/zh/posts/cpp%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1/","summary":"\u003cp\u003e\u003cstrong\u003e函数对象\u003c/strong\u003e（Function Objects）、\u003cstrong\u003eLambda 表达式\u003c/strong\u003e 和 \u003cstrong\u003e类的成员函数\u003c/strong\u003e 是 C++ 中调用函数行为的三种实现方式，它们在语法、用途和底层实现上有所不同。\u003c/p\u003e","title":"Cpp函数对象"},{"content":"C++ STL 中 map 与 unordered_map 的使用笔记和比较\n1. 简介 容器类型 map unordered_map 实现机制 红黑树（自平衡二叉搜索树） 哈希表 键的顺序 按键的升序（或自定义排序） 无序（哈希值决定元素位置） 时间复杂度 插入、删除、查找均为 O(log⁡n) 插入、删除、查找均为 O(1)（均摊复杂度） 内存使用 较少 较多（需要额外的哈希表存储） 适用场景 需要有序的数据（按键排序） 快速查找、插入，且不要求有序 线程安全性 非线程安全 非线程安全 2. 头文件 1 2 #include \u0026lt;map\u0026gt; #include \u0026lt;unordered_map\u0026gt; 3. 基本操作比较 定义和初始化 1 2 3 4 5 6 7 8 9 10 std::map\u0026lt;KeyType, ValueType, Compare\u0026gt; std::unordered_map\u0026lt;KeyType, ValueType, Hash, KeyEqual\u0026gt; std::map\u0026lt;int, std::string\u0026gt; m; std::unordered_map\u0026lt;int, std::string\u0026gt; um; std::map\u0026lt;int, std::string\u0026gt; m2 = {{1, \u0026#34;one\u0026#34;}, {2, \u0026#34;two\u0026#34;}}; std::unordered_map\u0026lt;int, std::string\u0026gt; um2 = {{1, \u0026#34;one\u0026#34;}, {2, \u0026#34;two\u0026#34;}}; 插入元素 1 2 3 4 5 6 7 8 m[1] = \u0026#34;hello\u0026#34;; um[1] = \u0026#34;hello\u0026#34;; m.insert({2, \u0026#34;world\u0026#34;}); um.insert({2, \u0026#34;world\u0026#34;}); m.emplace(3, \u0026#34;C++\u0026#34;); um.emplace(3, \u0026#34;C++\u0026#34;); 访问元素 1 2 3 4 5 std::string val = m[1]; // 若键不存在，会创建默认值 std::string val = um[1]; // 若键不存在，也会创建默认值 std::string val = m.at(2); // 若键不存在，抛出异常 std::string val = um.at(2); // 同上 查找元素 1 2 3 4 5 6 7 if (m.find(3) != m.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found in map\u0026#34; \u0026lt;\u0026lt; std::endl; } if (um.find(3) != um.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;Found in unordered_map\u0026#34; \u0026lt;\u0026lt; std::endl; } 遍历容器 1 2 3 4 5 6 7 8 9 // 遍历 map for (const auto\u0026amp; [key, value] : m) { std::cout \u0026lt;\u0026lt; \u0026#34;Key: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;, Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } // 遍历 unordered_map for (const auto\u0026amp; [key, value] : um) { std::cout \u0026lt;\u0026lt; \u0026#34;Key: \u0026#34; \u0026lt;\u0026lt; key \u0026lt;\u0026lt; \u0026#34;, Value: \u0026#34; \u0026lt;\u0026lt; value \u0026lt;\u0026lt; std::endl; } 删除元素 1 2 3 4 5 m.erase(1); // 按键值删除 um.erase(1); // 同上 m.erase(m.begin()); // 按迭代器删除 um.erase(um.begin()); 清空容器 1 2 m.clear(); um.clear(); 4. 性能对比 时间复杂度\nmap: 插入、删除、查找的时间复杂度为 O(log⁡n)O(\\log n)，适合需要有序数据的场景。 unordered_map: 插入、删除、查找的均摊时间复杂度为 O(1)O(1)，适合快速查找的场景。 内存占用\nmap: 内存占用较低。 unordered_map: 由于哈希表的开销（如桶分配），内存占用较高。 顺序性\nmap: 数据按键升序存储，遍历结果有序。 unordered_map: 数据无序，遍历顺序与插入顺序无关。 自定义排序\nmap: 支持通过比较器自定义排序。 unordered_map: 不支持排序。 5. 示例代码：性能和特性对比 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include \u0026lt;iostream\u0026gt; #include \u0026lt;map\u0026gt; #include \u0026lt;unordered_map\u0026gt; #include \u0026lt;chrono\u0026gt; int main() { const int n = 1000000; // 初始化 std::map\u0026lt;int, int\u0026gt; m; std::unordered_map\u0026lt;int, int\u0026gt; um; // 插入性能 auto start = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u0026lt; n; ++i) { m[i] = i; } auto end = std::chrono::high_resolution_clock::now(); std::cout \u0026lt;\u0026lt; \u0026#34;map insertion time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(end - start).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; std::endl; start = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u0026lt; n; ++i) { um[i] = i; } end = std::chrono::high_resolution_clock::now(); std::cout \u0026lt;\u0026lt; \u0026#34;unordered_map insertion time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(end - start).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; std::endl; // 查找性能 start = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u0026lt; n; ++i) { m.find(i); } end = std::chrono::high_resolution_clock::now(); std::cout \u0026lt;\u0026lt; \u0026#34;map find time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(end - start).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; std::endl; start = std::chrono::high_resolution_clock::now(); for (int i = 0; i \u0026lt; n; ++i) { um.find(i); } end = std::chrono::high_resolution_clock::now(); std::cout \u0026lt;\u0026lt; \u0026#34;unordered_map find time: \u0026#34; \u0026lt;\u0026lt; std::chrono::duration_cast\u0026lt;std::chrono::milliseconds\u0026gt;(end - start).count() \u0026lt;\u0026lt; \u0026#34; ms\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 6. 选择建议 使用 map 的场景：\n需要保持键值对的有序性。 需要按顺序遍历键值对。 数据规模较小且性能要求不高。 使用 unordered_map 的场景：\n主要需求是快速查找、插入、删除。 不关心键值对的存储顺序。 数据规模较大，性能优先。 ","permalink":"http://119.91.218.8/zh/posts/cppstl-map%E7%B3%BB%E5%88%97/","summary":"\u003cp\u003eC++ STL 中 \u003ccode\u003emap\u003c/code\u003e 与 \u003ccode\u003eunordered_map\u003c/code\u003e 的使用笔记和比较\u003c/p\u003e\n\u003ch4 id=\"1-简介\"\u003e1. \u003cstrong\u003e简介\u003c/strong\u003e\u003c/h4\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e容器类型\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003e\u003ccode\u003emap\u003c/code\u003e\u003c/strong\u003e\u003c/th\u003e\n          \u003cth\u003e\u003cstrong\u003e\u003ccode\u003eunordered_map\u003c/code\u003e\u003c/strong\u003e\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e实现机制\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e红黑树（自平衡二叉搜索树）\u003c/td\u003e\n          \u003ctd\u003e哈希表\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e键的顺序\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e按键的升序（或自定义排序）\u003c/td\u003e\n          \u003ctd\u003e无序（哈希值决定元素位置）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e时间复杂度\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e插入、删除、查找均为 O(log⁡n)\u003c/td\u003e\n          \u003ctd\u003e插入、删除、查找均为 O(1)（均摊复杂度）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e内存使用\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e较少\u003c/td\u003e\n          \u003ctd\u003e较多（需要额外的哈希表存储）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e适用场景\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e需要有序的数据（按键排序）\u003c/td\u003e\n          \u003ctd\u003e快速查找、插入，且不要求有序\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e\u003cstrong\u003e线程安全性\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd\u003e非线程安全\u003c/td\u003e\n          \u003ctd\u003e非线程安全\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003chr\u003e\n\u003ch4 id=\"2-头文件\"\u003e2. \u003cstrong\u003e头文件\u003c/strong\u003e\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;map\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#include\u003c/span\u003e \u003cspan class=\"cpf\"\u003e\u0026lt;unordered_map\u0026gt;\u003c/span\u003e\u003cspan class=\"cp\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003chr\u003e\n\u003ch4 id=\"3-基本操作比较\"\u003e3. \u003cstrong\u003e基本操作比较\u003c/strong\u003e\u003c/h4\u003e\n\u003ch5 id=\"定义和初始化\"\u003e定义和初始化\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKeyType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eValueType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eCompare\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunordered_map\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eKeyType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eValueType\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eHash\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eKeyEqual\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunordered_map\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003emap\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003em2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{{\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;one\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;two\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e}};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eunordered_map\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eum2\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e{{\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;one\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e},\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;two\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e}};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"插入元素\"\u003e插入元素\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;hello\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einsert\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003einsert\u003c/span\u003e\u003cspan class=\"p\"\u003e({\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;world\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eemplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;C++\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eemplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;C++\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"访问元素\"\u003e访问元素\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e    \u003cspan class=\"c1\"\u003e// 若键不存在，会创建默认值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e];\u003c/span\u003e   \u003cspan class=\"c1\"\u003e// 若键不存在，也会创建默认值\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 若键不存在，抛出异常\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eval\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eat\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e2\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e \u003cspan class=\"c1\"\u003e// 同上\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"查找元素\"\u003e查找元素\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Found in map\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003efind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e!=\u003c/span\u003e \u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e())\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Found in unordered_map\u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"遍历容器\"\u003e遍历容器\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 遍历 map\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003eauto\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Key: \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;, Value: \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 遍历 unordered_map\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"k\"\u003efor\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"k\"\u003eauto\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003ekey\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e]\u003c/span\u003e \u003cspan class=\"o\"\u003e:\u003c/span\u003e \u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003ecout\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Key: \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003ekey\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;, Value: \u0026#34;\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003evalue\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"n\"\u003estd\u003c/span\u003e\u003cspan class=\"o\"\u003e::\u003c/span\u003e\u003cspan class=\"n\"\u003eendl\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"删除元素\"\u003e删除元素\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eerase\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e        \u003cspan class=\"c1\"\u003e// 按键值删除\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eerase\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e       \u003cspan class=\"c1\"\u003e// 同上\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eerase\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e  \u003cspan class=\"c1\"\u003e// 按迭代器删除\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eerase\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e());\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch5 id=\"清空容器\"\u003e清空容器\u003c/h5\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-cpp\" data-lang=\"cpp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003em\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eclear\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eum\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eclear\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003chr\u003e\n\u003ch4 id=\"4-性能对比\"\u003e4. \u003cstrong\u003e性能对比\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e时间复杂度\u003c/strong\u003e\u003c/p\u003e","title":"CppSTL map系列"},{"content":"前言 两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。\n遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。\n以下的两种方法分别使用排序和计数作为哈希表的键。\n方法一：排序 由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; mp; for (string\u0026amp; str: strs) { string key = str; sort(key.begin(), key.end()); mp[key].emplace_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for (auto it = mp.begin(); it != mp.end(); ++it) { ans.emplace_back(it-\u0026gt;second); } return ans; } }; 复杂度分析 时间复杂度：$O(nklogk)$，其中 $n$ 是 $strs$ 中的字符串的数量，$k$ 是 $strs$ 中的字符串的的最大长度。需要遍历 $n$ 个字符串，对于每个字符串，需要 $O(klogk)$ 的时间进行排序以及 $O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(nklogk)$。\n空间复杂度：$O(nk)$，其中 $n$ 是 $strs$ 中的字符串的数量，$k$ 是 $strs$ 中的字符串的的最大长度。需要用哈希表存储全部字符串。\n方法二：计数 由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。\n由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { // 自定义对 array\u0026lt;int, 26\u0026gt; 类型的哈希函数 auto arrayHash = [fn = hash\u0026lt;int\u0026gt;{}] (const array\u0026lt;int, 26\u0026gt;\u0026amp; arr) -\u0026gt; size_t { return accumulate(arr.begin(), arr.end(), 0u, [\u0026amp;](size_t acc, int num) { return (acc \u0026lt;\u0026lt; 1) ^ fn(num); }); }; unordered_map\u0026lt;array\u0026lt;int, 26\u0026gt;, vector\u0026lt;string\u0026gt;, decltype(arrayHash)\u0026gt; mp(0, arrayHash); for (string\u0026amp; str: strs) { array\u0026lt;int, 26\u0026gt; counts{}; int length = str.length(); for (int i = 0; i \u0026lt; length; ++i) { counts[str[i] - \u0026#39;a\u0026#39;] ++; } mp[counts].emplace_back(str); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for (auto it = mp.begin(); it != mp.end(); ++it) { ans.emplace_back(it-\u0026gt;second); } return ans; } }; 复杂度分析\n时间复杂度：$O(n(k+∣Σ∣))$，其中 $n$ 是 $strs$ 中的字符串的数量，$k$ 是 $strs$ 中的字符串的的最大长度，$Σ$ 是字符集，在本题中字符集为所有小写字母，$∣Σ∣=26$。需要遍历 $n$ 个字符串，对于每个字符串，需要 $O(k)$ 的时间计算每个字母出现的次数，$O(∣Σ∣)$ 的时间生成哈希表的键，以及$O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(n(k+∣Σ∣))$。\n空间复杂度：$O(n(k+∣Σ∣))$，其中 n 是 strs 中的字符串的数量，$k$ 是 $strs$ 中的字符串的最大长度，$Σ$ 是字符集，在本题中字符集为所有小写字母，$∣Σ∣=26$。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 $O(∣Σ∣)$，在渐进意义下小于 $O(n(k+∣Σ∣))$，可以忽略不计。\n","permalink":"http://119.91.218.8/zh/posts/leetcode-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。\u003c/p\u003e","title":"leetcode 49 字母异位词"},{"content":"在leetcode 49中的官方解答存在lambda表达式，与decltype与自定已哈希函数的用法的例子\n1 2 3 4 5 auto arrayHash = [fn = hash\u0026lt;int\u0026gt;{}] (const array\u0026lt;int, 26\u0026gt;\u0026amp; arr) -\u0026gt; size_t { return accumulate(arr.begin(), arr.end(), 0u, [\u0026amp;](size_t acc, int num) { return (acc \u0026lt;\u0026lt; 1) ^ fn(num); }); }; 1 自定义哈希函数 背景： 在 std::unordered_map 或 std::unordered_set 中，键需要能够被哈希以支持高效查找。C++ 标准库对基本类型（如 int、std::string 等）和部分标准容器（如 std::pair）提供了默认的哈希实现。但对于一些自定义类型（如 std::array\u0026lt;int, 26\u0026gt;），没有默认的哈希函数，需要开发者提供。\n定义自定义哈希函数： 自定义哈希函数通常是一个函数对象或 lambda 表达式，用于对键进行哈希计算。\n示例：\n1 2 3 4 5 auto customHash = [](const std::array\u0026lt;int, 26\u0026gt;\u0026amp; arr) -\u0026gt; size_t { return std::accumulate(arr.begin(), arr.end(), 0u, [](size_t acc, int num) { return acc ^ std::hash\u0026lt;int\u0026gt;{}(num); }); }; 作用： 通过自定义哈希函数，开发者可以定义如何为复杂类型生成哈希值。这种能力尤其重要，用于支持非标准类型作为键的容器。\n2 Lambda 表达式捕获 Lambda 表达式是 C++ 中的一种轻量级语法，用于定义匿名函数。它可以在代码中直接定义并使用，没有名字，也无需单独声明，可以捕获周围作用域中的变量。这使得它非常适合需要临时定义简单函数的场景。\nLambda 表达式在 C++11 中引入，并在后续标准（C++14、C++17 等）中得到了增强。\nLambda 表达式的基本结构 Lambda 表达式的基本语法如下：\n1 2 3 [捕获列表](参数列表) -\u0026gt; 返回类型 { 函数体 }; 分解各部分： 捕获列表 []: 用于捕获外部作用域中的变量，可以按值或按引用捕获，也可以进行初始化。 参数列表 (): 类似于普通函数的参数列表，可以为空。 返回类型 -\u0026gt;: 明确指定函数的返回类型，可省略（在大多数情况下可以自动推导）。 函数体 {}: 包含函数的逻辑，类似于普通函数的实现部分。 示例代码 简单例子： 1 2 3 4 5 auto add = [](int a, int b) -\u0026gt; int { return a + b; }; int result = add(3, 5); // result = 8 解释： [ ]：捕获列表为空，表示不使用外部变量。 (int a, int b)：函数接受两个参数 a 和 b。 -\u0026gt; int：函数返回类型是 int。 { return a + b; }：函数体计算 a + b 并返回结果。 捕获外部变量： 1 2 3 4 5 6 7 8 9 int x = 10; int y = 20; auto multiply = [x, \u0026amp;y](int z) -\u0026gt; int { y += 10; // y 按引用捕获，可以被修改 return x * y * z; }; int result = multiply(2); // result = 10 * 30 * 2 = 600 解释： [x, \u0026amp;y]：按值捕获 x，按引用捕获 y。 y 在 lambda 内可以被修改，而 x 不会被改变。 省略返回类型： C++14 开始支持自动返回类型推导，因此返回类型可以省略。\n1 2 3 auto subtract = [](int a, int b) { return a - b; }; 捕获列表的形式 按值捕获 [x]: 捕获外部变量的副本，lambda 内修改不会影响原变量。\n1 2 int x = 10; auto lambda = [x]() { return x + 1; }; 按引用捕获 [\u0026amp;x]: 捕获外部变量的引用，lambda 内修改会影响原变量。\n1 2 3 int x = 10; auto lambda = [\u0026amp;x]() { x += 1; }; lambda(); // x 被修改为 11 捕获所有变量 [=] 或 [\u0026amp;]:\n[=]：按值捕获所有变量。 [\u0026amp;]：按引用捕获所有变量。 1 2 3 int x = 10, y = 20; auto lambda1 = [=]() { return x + y; }; // 按值捕获 x 和 y auto lambda2 = [\u0026amp;]() { x += y; }; // 按引用捕获 x 和 y 初始化捕获 [var = expr]: C++14 开始支持在捕获列表中初始化变量。\n1 2 3 auto lambda = [sum = 10](int value) { return sum + value; }; Lambda 表达式的用途 临时函数定义： 使用 lambda 表达式可以避免单独声明一个函数，非常适合仅在特定上下文中使用的小型函数。\n与标准库算法结合： 在使用 std::for_each、std::sort 等标准算法时，lambda 表达式常用作自定义逻辑的传递。\n1 2 3 4 std::vector\u0026lt;int\u0026gt; nums = {1, 2, 3, 4}; std::for_each(nums.begin(), nums.end(), [](int n) { std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; }); 作为回调函数： Lambda 表达式可以用作回调函数，例如事件处理或线程任务。\n1 2 3 4 std::thread t([] { std::cout \u0026lt;\u0026lt; \u0026#34;Thread running!\u0026#34; \u0026lt;\u0026lt; std::endl; }); t.join(); 捕获外部变量： 可以灵活地使用捕获列表传递外部数据，避免显式传参的麻烦。\n3 decltype 背景： decltype 是 C++11 引入的一个关键字，用于推导表达式的类型。它和 auto 类似，但更适合需要明确表达式类型的场景。\n用法： 推导变量类型：\n1 2 int x = 10; decltype(x) y = 20; // y 的类型与 x 相同，为 int 用于函数返回值：\n1 2 3 auto func = [](int a, int b) -\u0026gt; decltype(a + b) { return a + b; }; 在示例中的作用： decltype(arrayHash) 推导出 arrayHash 的类型（std::function\u0026lt;size_t(const std::array\u0026lt;int, 26\u0026gt;\u0026amp;)\u0026gt;），并将其用作 unordered_map 的第三个模板参数。\n4 std::accumulate 背景： std::accumulate 是 C++ 标准库提供的算法，用于对一个范围内的所有元素进行累积操作。\n定义： 1 2 template\u0026lt;class InputIt, class T, class BinaryOperation\u0026gt; T accumulate(InputIt first, InputIt last, T init, BinaryOperation op); 参数： InputIt first, InputIt last：范围的起始和结束迭代器。 T init：累积的初始值。 BinaryOperation op：二元操作函数，用于定义累积规则。 用法： 示例：累加一个整数数组：\n1 2 std::vector\u0026lt;int\u0026gt; vec = {1, 2, 3}; int sum = std::accumulate(vec.begin(), vec.end(), 0); // sum = 6 示例：自定义操作规则：\n1 2 3 int hashValue = std::accumulate(arr.begin(), arr.end(), 0u, [](size_t acc, int num) { return acc ^ std::hash\u0026lt;int\u0026gt;{}(num); }); 在示例中的作用： std::accumulate 被用来遍历 std::array\u0026lt;int, 26\u0026gt; 的所有元素，将每个元素的哈希值累积成一个最终的哈希值。\n","permalink":"http://119.91.218.8/zh/posts/cpp-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E4%B8%8Edecltype/","summary":"\u003cp\u003e在leetcode 49中的官方解答存在lambda表达式，与decltype与自定已哈希函数的用法的例子\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-c++\" data-lang=\"c++\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003eauto\u003c/span\u003e \u003cspan class=\"n\"\u003earrayHash\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"n\"\u003efn\u003c/span\u003e \u003cspan class=\"o\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003ehash\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"p\"\u003e{}]\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003econst\u003c/span\u003e \u003cspan class=\"n\"\u003earray\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"mi\"\u003e26\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u0026amp;\u003c/span\u003e \u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e-\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"nf\"\u003eaccumulate\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ebegin\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"n\"\u003earr\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eend\u003c/span\u003e\u003cspan class=\"p\"\u003e(),\u003c/span\u003e \u003cspan class=\"mi\"\u003e0u\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e[\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026amp;\u003c/span\u003e\u003cspan class=\"p\"\u003e](\u003c/span\u003e\u003cspan class=\"n\"\u003esize_t\u003c/span\u003e \u003cspan class=\"n\"\u003eacc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eacc\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e \u003cspan class=\"mi\"\u003e1\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"o\"\u003e^\u003c/span\u003e \u003cspan class=\"n\"\u003efn\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003enum\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1-自定义哈希函数\"\u003e\u003cstrong\u003e1 自定义哈希函数\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"背景\"\u003e\u003cstrong\u003e背景：\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e在 \u003ccode\u003estd::unordered_map\u003c/code\u003e 或 \u003ccode\u003estd::unordered_set\u003c/code\u003e 中，键需要能够被哈希以支持高效查找。C++ 标准库对基本类型（如 \u003ccode\u003eint\u003c/code\u003e、\u003ccode\u003estd::string\u003c/code\u003e 等）和部分标准容器（如 \u003ccode\u003estd::pair\u003c/code\u003e）提供了默认的哈希实现。但对于一些自定义类型（如 \u003ccode\u003estd::array\u0026lt;int, 26\u0026gt;\u003c/code\u003e），没有默认的哈希函数，需要开发者提供。\u003c/p\u003e","title":"cpp Lambda表达式与自定义哈希函数与decltype"},{"content":"总结表 用途 含义 示例 地址运算符 获取变量的地址 int* ptr = \u0026amp;x; 引用声明 声明一个变量的引用 int\u0026amp; ref = x; 按位与 执行按位与操作 int c = a \u0026amp; b; 左值引用 函数接受一个左值引用 void func(int\u0026amp; n); 右值引用（\u0026amp;\u0026amp;） 函数接受一个右值引用 void func(int\u0026amp;\u0026amp; n); 函数返回类型 返回一个引用 int\u0026amp; func(); 类型推导 使用 decltype 推导引用类型 decltype(x)\u0026amp; ref = x; 指针和引用类型 在类型声明中表示引用或地址操作 int* ptr = \u0026amp;x; 重载运算符 自定义按位与或按位与赋值运算符 Example\u0026amp; operator\u0026amp;(Example); 1. 地址运算符 \u0026amp; 用于获取变量的内存地址。\n示例：\n1 2 int x = 10; int* ptr = \u0026amp;x; // 获取 x 的地址并存储在指针 ptr 中 作用：获取变量的地址。\n2. 引用声明 \u0026amp; 用于声明一个变量的引用（reference）。\n示例：\n1 2 3 int x = 10; int\u0026amp; ref = x; // ref 是 x 的引用 ref = 20; // 修改 ref 也会修改 x 作用：为一个变量创建别名，操作引用会直接影响原变量。\n3. 按位与运算符 \u0026amp; 用于按位与（bitwise AND）操作。\n示例：\n1 2 3 int a = 5; // 二进制: 0101 int b = 3; // 二进制: 0011 int c = a \u0026amp; b; // c = 1 (二进制: 0001) 作用：逐位比较两个整数，每个位都执行 AND 操作。\n4. 左值引用（Lvalue Reference） 当 \u0026amp; 出现在函数形参中时，表示接受一个左值引用。\n示例：\n1 2 3 4 5 void increment(int\u0026amp; n) { // 接受一个左值引用 n++; } int x = 10; increment(x); // x 被修改为 11 作用：允许直接操作传入变量。\n5. 右值引用（Rvalue Reference，C++11 引入） 当使用 \u0026amp;\u0026amp; 时，表示右值引用。\n示例：\n1 2 3 4 void process(int\u0026amp;\u0026amp; n) { // 接受一个右值引用 n++; } process(10); // 10 是右值 作用：右值引用通常用于移动语义和完美转发。\n6. 在类型声明中的符号 \u0026amp; 出现在函数返回类型或参数类型中，用于表示返回值或参数是一个引用。\n示例：\n1 2 3 int x = 10; int\u0026amp; getRef() { return x; } // 返回 x 的引用 int\u0026amp; ref = getRef(); // ref 是 x 的引用 7. 结合 decltype 推导类型 在类型推导中，\u0026amp; 表示引用类型。\n示例：\n1 2 int x = 10; decltype(x)\u0026amp; ref = x; // ref 是 int 的引用 8. 用于指针与引用类型 当 \u0026amp; 出现在类型声明中时，它可以表示引用或指针类型的操作。\n示例：\n1 2 3 int x = 10; int* ptr = \u0026amp;x; // 指针，存储地址 int\u0026amp; ref = x; // 引用，别名 9. 重载运算符 \u0026amp; 和 \u0026amp;= 运算符可以被重载为类的成员或非成员函数。\n示例：\n1 2 3 4 5 6 7 class Example { public: Example\u0026amp; operator\u0026amp;(const Example\u0026amp; other) { // 自定义按位与操作 return *this; } }; ","permalink":"http://119.91.218.8/zh/posts/and-%E7%AC%A6%E5%8F%B7%E5%9C%A8cpp%E4%B8%AD%E7%9A%84%E7%94%A8%E9%80%94/","summary":"\u003ch3 id=\"总结表\"\u003e\u003cstrong\u003e总结表\u003c/strong\u003e\u003c/h3\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e用途\u003c/th\u003e\n          \u003cth\u003e含义\u003c/th\u003e\n          \u003cth\u003e示例\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e地址运算符\u003c/td\u003e\n          \u003ctd\u003e获取变量的地址\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eint* ptr = \u0026amp;x;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e引用声明\u003c/td\u003e\n          \u003ctd\u003e声明一个变量的引用\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eint\u0026amp; ref = x;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e按位与\u003c/td\u003e\n          \u003ctd\u003e执行按位与操作\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eint c = a \u0026amp; b;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e左值引用\u003c/td\u003e\n          \u003ctd\u003e函数接受一个左值引用\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003evoid func(int\u0026amp; n);\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e右值引用（\u003ccode\u003e\u0026amp;\u0026amp;\u003c/code\u003e）\u003c/td\u003e\n          \u003ctd\u003e函数接受一个右值引用\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003evoid func(int\u0026amp;\u0026amp; n);\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e函数返回类型\u003c/td\u003e\n          \u003ctd\u003e返回一个引用\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eint\u0026amp; func();\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e类型推导\u003c/td\u003e\n          \u003ctd\u003e使用 \u003ccode\u003edecltype\u003c/code\u003e 推导引用类型\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003edecltype(x)\u0026amp; ref = x;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e指针和引用类型\u003c/td\u003e\n          \u003ctd\u003e在类型声明中表示引用或地址操作\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eint* ptr = \u0026amp;x;\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e重载运算符\u003c/td\u003e\n          \u003ctd\u003e自定义按位与或按位与赋值运算符\u003c/td\u003e\n          \u003ctd\u003e\u003ccode\u003eExample\u0026amp; operator\u0026amp;(Example);\u003c/code\u003e\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3 id=\"1-地址运算符\"\u003e\u003cstrong\u003e1. 地址运算符\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003e\u0026amp;\u003c/code\u003e 用于获取变量的内存地址。\u003c/p\u003e","title":"and 符号在cpp中的用途"},{"content":"在 C++ 的 STL 容器（如 std::vector、std::deque）中，push_back 和 emplace_back 是用于在容器尾部插入元素的两种方法，它们的主要区别在于插入方式和效率。\npush_back 功能：将一个对象添加到容器的尾部。\n实现方式：\n需要一个已经构造好的对象。 将该对象复制（或移动）到容器中。 使用示例：\n1 2 std::vector\u0026lt;std::pair\u0026lt;int, std::string\u0026gt;\u0026gt; vec; vec.push_back(std::make_pair(1, \u0026#34;example\u0026#34;)); // 必须先创建 std::make_pair 对象 缺点：\n如果对象的构造很昂贵，push_back 会产生额外的开销（复制或移动的开销）。 无法直接在容器中原地构造对象。 emplace_back 功能：在容器尾部直接构造对象。\n实现方式：\n通过传递构造函数的参数，直接在容器的存储位置构造对象。 避免了多余的复制或移动。 使用示例：\n1 2 std::vector\u0026lt;std::pair\u0026lt;int, std::string\u0026gt;\u0026gt; vec; vec.emplace_back(1, \u0026#34;example\u0026#34;); // 直接在容器中构造对象 优点：\n提高了效率，因为省略了中间的临时对象创建和销毁。 更灵活，允许直接传递构造函数参数。 对比总结 特性 push_back emplace_back 调用方式 需要一个已构造的对象 直接传递构造函数参数 性能 可能有额外的复制或移动开销 避免了复制或移动，效率更高 使用场景 已有一个现成的对象 需要直接在容器中构造对象 可读性 较简单，适合已有对象的插入 较复杂，但在某些场景下更加高效 选择建议 如果已有对象且不关心额外开销，可以使用 push_back。 如果希望避免临时对象的构造，或者希望通过构造函数直接初始化对象，使用 emplace_back 更合适。 注意事项 如果构造参数传递有歧义（如多种重载构造函数），emplace_back 的行为可能更复杂，应小心使用。 对于简单类型（如 int、double），两者性能几乎无差别。 emplace_back 在某些情况下可能会导致危险行为，特别是当构造函数存在多个重载或隐式类型转换时，这可能导致程序选择了错误的构造函数，进而引发逻辑错误或意外行为。\n危险例子 假设我们有一个类 Example，其构造函数有多种重载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;vector\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; class Example { public: Example(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor with int: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } Example(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor with string: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } }; 我们尝试使用 emplace_back 向 std::vector\u0026lt;Example\u0026gt; 中插入对象：\n1 2 3 4 5 6 7 8 int main() { std::vector\u0026lt;Example\u0026gt; vec; vec.emplace_back(42); // 调用 int 构造函数，输出：Constructor with int: 42 vec.emplace_back(\u0026#34;hello\u0026#34;); // 调用 string 构造函数，输出：Constructor with string: hello vec.emplace_back(\u0026#39;a\u0026#39;); // 这里会调用哪个构造函数？ } 问题分析 在最后一行 vec.emplace_back('a'); 中：\n'a' 是一个字符（char）。 char 类型可以隐式转换为 int，因此会选择 Example(int) 构造函数，而不是 Example(const std::string\u0026amp;) 构造函数。 这可能不是我们预期的行为，尤其是在类的构造函数设计复杂或含有隐式转换时。\n运行结果 输出如下：\n1 2 3 Constructor with int: 42 Constructor with string: hello Constructor with int: 97 注意到 'a' 被转换为了 ASCII 值 97，并调用了 Example(int) 构造函数。这可能会导致逻辑错误或意外行为。\n如何避免？ 显式构造函数： 将构造函数声明为 explicit，避免隐式类型转换。\n1 2 3 4 5 6 7 8 9 class Example { public: explicit Example(int x) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor with int: \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } explicit Example(const std::string\u0026amp; str) { std::cout \u0026lt;\u0026lt; \u0026#34;Constructor with string: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; std::endl; } }; 如果尝试 vec.emplace_back('a');，编译器会报错，强制开发者明确指定意图。\n代码审查： 在使用 emplace_back 时，确保传递的参数类型和构造函数匹配，避免隐式转换。\n使用 push_back 或直接构造： 当逻辑复杂或类型歧义可能存在时，显式构造对象并使用 push_back，可提升代码可读性。\n1 vec.push_back(Example(\u0026#39;a\u0026#39;)); ","permalink":"http://119.91.218.8/zh/posts/cpp-stl-pushback-%E4%B8%8E-emplace_back%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"\u003cp\u003e在 C++ 的 STL 容器（如 \u003ccode\u003estd::vector\u003c/code\u003e、\u003ccode\u003estd::deque\u003c/code\u003e）中，\u003ccode\u003epush_back\u003c/code\u003e 和 \u003ccode\u003eemplace_back\u003c/code\u003e 是用于在容器尾部插入元素的两种方法，它们的主要区别在于插入方式和效率。\u003c/p\u003e","title":"cpp STL pushback 与 emplace_back的区别"},{"content":"Sherman-Morrison 公式是线性代数中的一个重要结果，用于计算一个可逆矩阵经过秩为 1 的更新后的逆矩阵。具体来说，当我们有一个可逆的 $n \\times n$矩阵$A$ 和两个列向量$u$、$v$ 时，Sherman-Morrison 公式给出了矩阵$A + u v^\\top$ 的逆的显式表达式。\n公式如下：\n$$ (A + u v^\\top)^{-1} = A^{-1} - \\frac{A^{-1} u v^\\top A^{-1}}{1 + v^\\top A^{-1} u} $$ 解释：\n$A$是一个可逆的$n \\times n$矩阵。 $u$和$v$是$n \\times 1$的列向量。 $u v^\\top$是一个$n \\times n$的矩阵，且秩为 1，因为它是两个向量的外积。 $A + u v^\\top$表示对矩阵$A$进行了一次秩为 1 的更新。 $A^{-1}$是矩阵$A$的逆矩阵。 分母中的$1 + v^\\top A^{-1} u$是一个标量。 应用： Sherman-Morrison 公式在数值计算中非常有用，因为它允许我们在已知$A^{-1}$的情况下，高效地计算$A + u v^\\top$的逆，而不需要对整个矩阵重新求逆。这对于处理大型矩阵或需要重复更新的情况下，能显著降低计算成本。 在您的问题中的应用： 在您的问题中，我们需要计算矩阵$(I_m + \\mathbf{1}_m \\mathbf{1}_m^\\top)^{-1}$，其中 $I_m$是$m \\times m$的单位矩阵。 $\\mathbf{1}_m$是长度为$m$的全 1 列向量。 这是一个特定情况下的 Sherman-Morrison 公式应用： 取$A = I_m$，因此$A^{-1} = I_m$。 取$u = \\mathbf{1}_m$，$v = \\mathbf{1}_m$。 代入 Sherman-Morrison 公式： $$ \\begin{aligned} \\left( I_m + \\mathbf{1}_m \\mathbf{1}_m^\\top \\right)^{-1} \u0026= I_m^{-1} - \\frac{I_m^{-1} \\mathbf{1}_m \\mathbf{1}_m^\\top I_m^{-1}}{1 + \\mathbf{1}_m^\\top I_m^{-1} \\mathbf{1}_m} \\\\ \u0026= I_m - \\frac{\\mathbf{1}_m \\mathbf{1}_m^\\top}{1 + \\mathbf{1}_m^\\top \\mathbf{1}_m} \\end{aligned} $$ 因为：$\\mathbf{1}_m^\\top \\mathbf{1}_m = m$，所以分母为$1 + m$。\n最终得到： $$ (I_m + \\mathbf{1}_m \\mathbf{1}_m^\\top)^{-1} = I_m - \\frac{\\mathbf{1}_m \\mathbf{1}_m^\\top}{m + 1} $$ 总结： Sherman-Morrison 公式提供了一种高效的方法来计算秩为 1 更新矩阵的逆。\n","permalink":"http://119.91.218.8/zh/posts/sherman-morrison-%E5%85%AC%E5%BC%8F/","summary":"\u003cp\u003eSherman-Morrison 公式是线性代数中的一个重要结果，用于计算一个可逆矩阵经过秩为 1 的更新后的逆矩阵。具体来说，当我们有一个可逆的 $n \\times n$矩阵$A$ 和两个列向量$u$、$v$ 时，Sherman-Morrison 公式给出了矩阵$A + u v^\\top$ 的逆的显式表达式。\u003c/p\u003e","title":"Sherman-Morrison 公式"},{"content":"$$ H(X) = - \\sum_x p(x) \\log p(x) $$$$ H(X) = - \\int p(x) \\log p(x) \\, dx $$边际熵的解释 边际熵表示我们在知道变量 $X$ 的概率分布情况下，仍然对 $X$ 的取值存在的平均不确定性。它反映了 $X$ 本身携带的信息量。值越大，说明变量 $X$ 的不确定性越高，信息量也越多；相反，值越小，说明变量的取值更加确定。\n示例 $$ H(X) = -[0.5 \\log 0.5 + 0.5 \\log 0.5] = 1 $$在这种情况下，熵的值为1，表示对硬币的结果存在一定的不确定性。而如果 $X$ 是一个确定事件，比如始终为正面，那么 $H(X) = 0$，因为没有不确定性。\n","permalink":"http://119.91.218.8/zh/posts/%E8%BE%B9%E9%99%85%E7%86%B5marginal-entropy/","summary":"$$\nH(X) = - \\sum_x p(x) \\log p(x)\n$$$$\nH(X) = - \\int p(x) \\log p(x) \\, dx\n$$\u003ch3 id=\"边际熵的解释\"\u003e边际熵的解释\u003c/h3\u003e\n\u003cp\u003e边际熵表示我们在知道变量 $X$ 的概率分布情况下，仍然对 $X$ 的取值存在的平均不确定性。它反映了 $X$ 本身携带的信息量。值越大，说明变量 $X$ 的不确定性越高，信息量也越多；相反，值越小，说明变量的取值更加确定。\u003c/p\u003e","title":"边际熵（Marginal Entropy"},{"content":"这段内容涉及L平滑性在稀疏子空间中的推广和应用。经典的L平滑性定义用于描述函数在不同点之间的梯度变化程度。当函数在某个子空间（如稀疏子空间）中定义时，L平滑常数往往会减少，反映出函数在较小的区域内变化的“平滑性”增大。\nLipschitz连续性与梯度光滑性 Lipschitz连续性 $$ \\|f(x) - f(y)\\| \\leq L \\|x - y\\| $$ 则称 $f(x)$ 是Lipschitz连续的。而 $L$ 称为函数 $f(x)$ 的Lipschitz常数。 满足这个条件的函数有这样的性质 性质\n一致连续性: Lipschitz连续函数必定是一致连续的 有限变化率: Lipschitz连续函数必定有限的变化率 闭包性: Lipschitz连续函数在函数加法和数乘下是闭合的 梯度光滑性 $$ \\|\\nabla f(x) - \\nabla f(y)\\| \\leq L \\|x - y\\| $$ 则称$f(x)$是梯度光滑的。\n满足这个条件的函数有以下性质:\n二次可微性: Lipschitz光滑函数几乎处处二次可微，且hessian矩阵的最大特征值不超过$L$ Taylor展开: Lipschitz光滑函数的Taylor展开的形式为 $$ f(y) \\leq f(x) + \\langle \\nabla f(x), y - x\\rangle + \\frac{L}{2} \\|y - x\\|^2 $$ ","permalink":"http://119.91.218.8/zh/posts/lipschitz%E8%BF%9E%E7%BB%AD%E6%80%A7%E4%B8%8E%E6%94%B6%E6%95%9B%E6%80%A7/","summary":"\u003cp\u003e这段内容涉及\u003cstrong\u003eL平滑性\u003c/strong\u003e在\u003cstrong\u003e稀疏子空间\u003c/strong\u003e中的推广和应用。经典的L平滑性定义用于描述函数在不同点之间的梯度变化程度。当函数在某个子空间（如稀疏子空间）中定义时，L平滑常数往往会减少，反映出函数在较小的区域内变化的“平滑性”增大。\u003c/p\u003e","title":"Lipschitz连续性与收敛性"},{"content":"这段内容涉及L平滑性在稀疏子空间中的推广和应用。经典的L平滑性定义用于描述函数在不同点之间的梯度变化程度。当函数在某个子空间（如稀疏子空间）中定义时，L平滑常数往往会减少，反映出函数在较小的区域内变化的“平滑性”增大。以下是详细解释：\n$$ \\|\\nabla f(x) - \\nabla f(y)\\| \\leq L \\|x - y\\|, $$ 即函数在任意点之间的梯度差不会超过某个常数倍 $L$ 时，我们称 $f(x)$ 是L平滑的。\n$$ \\|\\nabla^2 f(x)\\| \\leq L。 $$$$ L = \\max_{x \\in \\mathbb{R}^d} \\|\\nabla^2 f(x)\\|。 $$$$ \\|\\nabla^2 f(x)\\| = \\max_{v \\in \\mathbb{R}^d \\setminus 0} \\frac{\\nabla^2 f(x) \\cdot v}{\\|v\\|} \\geq \\max_{v \\in S \\setminus 0} \\frac{\\nabla^2 f(x) \\cdot v}{\\|v\\|} $$ 表示了在子空间 $S \\subseteq \\mathbb{R}^d$中，Hessian对该子空间的影响小于或等于整个空间中的情况，因此L平滑常数在稀疏子空间内可能降低。\n综上，通过限制定义域至稀疏子空间，L平滑性参数 $L$ 会相应地减小，这表明在稀疏子空间内函数更平滑。\n","permalink":"http://119.91.218.8/zh/posts/l%E5%B9%B3%E6%BB%91/","summary":"\u003cp\u003e这段内容涉及\u003cstrong\u003eL平滑性\u003c/strong\u003e在\u003cstrong\u003e稀疏子空间\u003c/strong\u003e中的推广和应用。经典的L平滑性定义用于描述函数在不同点之间的梯度变化程度。当函数在某个子空间（如稀疏子空间）中定义时，L平滑常数往往会减少，反映出函数在较小的区域内变化的“平滑性”增大。以下是详细解释：\u003c/p\u003e","title":"L平滑"},{"content":"Low-frequency inductive bias（低频归纳偏差）是一种在机器学习模型中的假设或倾向，特别是在深度学习领域，模型更容易学习低频信号或特征，而不是高频信号。简单来说，模型倾向于捕捉数据中的平滑、缓慢变化的模式，而不太容易学习快速变化或具有高频率的细节。\n背景 在神经网络中，尤其是卷积神经网络（CNNs）和变压器模型（Transformers），这种低频归纳偏差表现为网络能够更容易地捕捉到大尺度的全局结构（例如图像中的大区域或句子中的大范围上下文）。而小尺度的局部特征（例如图像中的细节边缘或句子中的局部依赖）则较难捕捉，因为它们通常表现为高频信号。\n原因 这种偏差可以从以下几方面解释：\n梯度优化过程：在模型的训练中，低频模式通常需要较少的参数调整，因此优化算法（如梯度下降）可以更快地学习这些模式。高频信号则更加复杂，可能需要更多的学习步骤才能有效捕捉。\n网络结构：网络层的设计（如卷积核大小、注意力机制的覆盖范围）常常天然偏向于捕捉平滑的或低频的特征。比如CNN中的大卷积核会更容易学习图像的全局特征，而较小的卷积核则专注于细节。\n傅里叶分析：研究表明，神经网络在频域上更容易学习低频的成分，这是因为高频信号在学习过程中通常需要更细腻的调整和更精细的权重分配。\n实际影响 低频归纳偏差在许多任务中有助于模型捕捉全局信息，但如果模型依赖于此偏差，可能会忽视一些关键的高频信号（例如图像的细微纹理，或文本中的精确语法结构）。这会导致模型在处理细节上表现不佳。\n为了解决这一问题，有时会通过调整模型结构、加入高频增强的正则化方法，或者通过数据增强来帮助模型学习高频特征。\n示例 图像处理：在图像分类任务中，低频归纳偏差会使模型更容易学习图像的整体轮廓或形状，而不是具体的细节如纹理或噪声。\n自然语言处理：在语言模型中，模型更倾向于学习句子的整体语义或长距离的上下文依赖，而忽视短语或单词之间的微妙关系。\n解决低频归纳偏差的策略 高频数据增强：通过数据增强策略（例如添加噪声、模糊处理等）提高模型对高频细节的敏感性。 多尺度特征融合：结合不同尺度的特征，比如在CNN中使用不同尺寸的卷积核，在变压器中使用多层次的注意力机制。 总之，low-frequency inductive bias 是神经网络中的一种偏好，它在某些任务中是有益的，但对于需要高精度特征识别的任务，可能会成为一种局限。\n可用的参考文献 On the spectral bias of neural networks. ICML 2019 Fourier features let networks learn high frequency functions in low dimensional domains NeurIPS 2020\n","permalink":"http://119.91.218.8/zh/posts/%E4%BD%8E%E9%A2%91%E5%BD%92%E7%BA%B3%E5%81%8F%E5%B7%AE%E5%81%87%E8%AE%BE/","summary":"\u003cp\u003eLow-frequency inductive bias（低频归纳偏差）是一种在机器学习模型中的假设或倾向，特别是在深度学习领域，模型更容易学习低频信号或特征，而不是高频信号。简单来说，模型倾向于捕捉数据中的平滑、缓慢变化的模式，而不太容易学习快速变化或具有高频率的细节。\u003c/p\u003e","title":"低频归纳偏差假设"},{"content":"1. 互信息（Mutual Information） 互信息 $I(h, x)$ 和 $I(h, y)$ 是用来衡量特征 $h$ 中包含的输入 $x$ 和标签 $y$ 的信息量的。互信息可以帮助我们了解特征中保留的总体信息量以及与任务相关的信息量。\n互信息公式：$I(h, x) = H(x) - H(x|h)$，表示在给定特征 $h$ 的条件下，输入 $x$ 的不确定性减少了多少。 任务相关信息：$I(h, y) = H(y) - H(y|h)$，用于衡量特征 $h$ 中关于标签 $y$ 的信息量。 2. 重构误差 $R(x|h)$ 重构误差 $R(x|h)$ 是估计 $I(h, x)$ 的一个关键指标。它表示通过特征 $h$ 来重构输入 $x$ 的误差大小。\n根据公式 $I(h, x) = H(x) - H(x|h) \\geq H(x) - R(x|h)$，互信息的下界可以用 $H(x) - R(x|h)$ 来近似计算。这是因为，如果能通过 $h$ 完美重构 $x$，则 $R(x|h)$ 趋于零，互信息 $I(h, x)$ 的估计值就会更接近真实值。\n近似计算：通过训练一个解码器来最小化 $R(x|h)$，我们可以获得 $I(h, x)$ 的估计值。 3. 二元交叉熵重构损失 在实践中，为了估计 $I(h, x)$，作者选择最小化二元交叉熵重构损失（Binary Cross-Entropy Loss），即计算每个像素的重构误差的平均值。这种方法可以有效地反映 $h$ 中保留的输入信息量。\n估计 $I(h, x)$ 的步骤： 训练解码器，使其输出尽量接近 $x$。 计算解码器的重构误差，以此为基础估计 $I(h, x)$。 最后将 $1 - \\text{AverageBinaryCrossEntropyLoss}(x|h)$ 作为 $I(h, x)$ 的近似值。 4. 辅助分类器估计 $I(h, y)$ 为了估计 $I(h, y)$，即特征 $h$ 中包含的与标签 $y$ 相关的信息量，作者使用一个辅助分类器。这个分类器用于模拟 $p(y|h)$ 的概率分布，并通过分类精度来近似衡量 $I(h, y)$。\n计算步骤： 定义 $I(h, y) = H(y) - H(y|h)$，其中 $H(y|h)$ 表示在给定 $h$ 的条件下 $y$ 的不确定性。 通过训练一个分类器来预测 $y$，并使用分类的准确性（即分类器的交叉熵损失）来估计 $I(h, y)$。 分类准确率越高，表明 $h$ 中包含的关于 $y$ 的信息量越多。 5. 总结数学方法 重构方法用于估计特征 $h$ 中保留的关于输入 $x$ 的信息 $I(h, x)$。 分类方法用于估计特征 $h$ 中保留的关于标签 $y$ 的信息 $I(h, y)$。 ","permalink":"http://119.91.218.8/zh/posts/%E4%BA%92%E4%BF%A1%E6%81%AF%E4%B8%8E%E6%A8%A1%E5%9E%8B/","summary":"\u003ch3 id=\"1-互信息mutual-information\"\u003e1. \u003cstrong\u003e互信息（Mutual Information）\u003c/strong\u003e\u003c/h3\u003e\n\u003cp\u003e互信息 $I(h, x)$ 和 $I(h, y)$ 是用来衡量特征 $h$ 中包含的输入 $x$ 和标签 $y$ 的信息量的。互信息可以帮助我们了解特征中保留的总体信息量以及与任务相关的信息量。\u003c/p\u003e","title":"互信息与模型"},{"content":"1. 安装 Fish Shell 步骤 更新系统：\n1 sudo apt update \u0026amp;\u0026amp; sudo apt upgrade -y 安装 Fish：\n1 sudo apt install fish -y 验证安装：\n1 fish --version 2. 设置 Fish 为默认 Shell 确认 Fish 的路径：\n1 which fish 通常路径为 /usr/bin/fish。\n将 Fish 设置为默认 Shell：\n1 chsh -s /usr/bin/fish 重新启动终端以应用更改。\n3. 安装 Fisher (Fish 的插件管理器) Fisher 是一个流行的插件管理器，用于轻松安装和管理 Fish 插件。\n安装 Fisher：\n1 curl -sL https://git.io/fisher | source \u0026amp;\u0026amp; fisher install jorgebucaran/fisher 验证安装：\n1 fisher --version 4. 安装常用插件 推荐以下常用插件：\n插件安装命令：\n1 fisher install \u0026lt;插件名\u0026gt; 推荐插件列表：\noh-my-fish/theme-bobthefish: 美观的主题。\n1 fisher install oh-my-fish/theme-bobthefish jorgebucaran/nvm.fish: Node.js 版本管理。\n1 fisher install jorgebucaran/nvm.fish PatrickF1/fzf.fish: 模糊查找。\n1 fisher install PatrickF1/fzf.fish jethrokuan/z: 快速目录跳转。\n1 fisher install jethrokuan/z franciscolourenco/done: 长时间命令完成时提醒。\n1 fisher install franciscolourenco/done 5. 配置 Fish Shell Fish 使用 $HOME/.config/fish/config.fish 文件来存储配置。可以编辑该文件以自定义你的 Shell。\n打开配置文件：\n1 nano ~/.config/fish/config.fish 添加一些常用配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 启用插件 fisher install oh-my-fish/theme-bobthefish # 设置别名 alias ll=\u0026#34;ls -lh\u0026#34; alias gs=\u0026#34;git status\u0026#34; # 设置 PATH set -x PATH $PATH /usr/local/bin # 自动跳转插件 jethrokuan/z # 启用语法高亮 fisher install ilancosman/tide 6. 美化 Shell 安装 Nerd Fonts: Nerd Fonts 提供丰富的图标支持。可以从 Nerd Fonts 官网 下载适合你的字体，并安装到系统中。\n更改终端字体：\n打开终端设置。 在外观设置中选择刚刚安装的 Nerd Font 字体。 启用主题：\n使用 bobthefish 或者 tide 主题进行美化：\n1 fisher install ilancosman/tide 运行 tide configure，根据提示完成配置。\n7. 启用自动补全和语法高亮 Fish 自带强大的自动补全功能，可以直接使用。 如果需要更高级的语法高亮，可以使用插件 tide。 8. 安装常用工具 fzf (模糊查找工具):\n1 sudo apt install fzf -y ripgrep (快速搜索工具):\n1 sudo apt install ripgrep -y 9. 备份和恢复配置 备份 将 ~/.config/fish 目录打包保存：\n1 tar -czvf fish-config-backup.tar.gz ~/.config/fish 恢复 将备份的文件解压到对应目录：\n1 tar -xzvf fish-config-backup.tar.gz -C ~/ 10. 测试配置 打开一个新的终端，确认配置生效。\n运行以下命令，验证所有功能：\n1 2 3 fish fisher list echo $PATH ","permalink":"http://119.91.218.8/zh/posts/fish-shell-%E9%85%8D%E7%BD%AE/","summary":"\u003ch3 id=\"1-安装-fish-shell\"\u003e\u003cstrong\u003e1. 安装 Fish Shell\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"步骤\"\u003e\u003cstrong\u003e步骤\u003c/strong\u003e\u003c/h4\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e更新系统：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt update \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e sudo apt upgrade -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e安装 Fish：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt install fish -y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e验证安装：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003efish --version\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3 id=\"2-设置-fish-为默认-shell\"\u003e\u003cstrong\u003e2. 设置 Fish 为默认 Shell\u003c/strong\u003e\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e确认 Fish 的路径：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewhich fish\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e通常路径为 \u003ccode\u003e/usr/bin/fish\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e将 Fish 设置为默认 Shell：\u003c/p\u003e","title":"fish shell 配置"},{"content":"在与他人协作开发一个功能时，使用 git rebase 可以保持提交历史的清洁和线性化。以下是一个推荐的 Git 工作流程，它结合了分支管理和 rebase，适合在多人协作中保持历史干净：\n1. 确保主分支是最新的 在开始新功能开发前，首先确保你的本地 main（或 master）分支与远程仓库同步：\n1 2 git checkout main git pull origin main 2. 从主分支创建一个新的功能分支 创建一个专门用于该功能开发的分支，通常基于 main 分支：\n1 git checkout -b feature-branch 3. 在功能分支上进行开发和提交 在 feature-branch 上进行开发，每次有进展时提交代码：\n1 2 git add \u0026lt;file\u0026gt; git commit -m \u0026#34;实现了部分功能\u0026#34; 4. 定期同步远程主分支 在开发过程中，其他开发者可能会向 main 分支推送新的提交。为了避免功能分支落后于主分支，可以定期将 main 的更新集成到你的功能分支中。这里建议使用 rebase 而不是 merge，这样可以保持线性历史：\n切换回 main 分支并获取最新的更新：\n1 2 git checkout main git pull origin main 回到你的功能分支并使用 rebase 来更新：\n1 2 git checkout feature-branch git rebase main 这样做会将你的功能分支上的提交“重新播放”到 main 分支的最新提交之后，保持提交历史干净。\n5. 解决冲突（如果有） 在 rebase 过程中，如果遇到冲突，Git 会暂停并提示你解决冲突。解决冲突后：\n1 2 git add \u0026lt;resolved-files\u0026gt; git rebase --continue 如果遇到无法解决的冲突或决定放弃当前的 rebase，可以使用：\n1 git rebase --abort 6. 完成功能开发后，更新功能分支 在功能开发完成准备提交之前，再次同步主分支：\n1 2 3 4 git checkout main git pull origin main git checkout feature-branch git rebase main 7. 推送功能分支 当功能开发完成，并且你确保功能分支与主分支已经同步后，你可以将功能分支推送到远程仓库。如果你在 rebase 过程中重写了提交历史，需要使用强制推送：\n1 git push --force-with-lease origin feature-branch --force-with-lease 是一种更安全的强制推送方式，它会检查远程仓库是否有新的提交，以避免误覆盖其他人的工作。\n8. 创建 Pull Request 并合并 当你推送了功能分支后，可以在远程仓库（如 GitHub、GitLab）上创建一个 Pull Request。建议在合并时选择“Squash and Merge”或“Rebase and Merge”方式，以保持提交历史的干净。\n9. 删除本地和远程功能分支 功能合并到主分支后，可以删除功能分支：\n1 2 git branch -d feature-branch git push origin --delete feature-branch 总结 这个流程的关键点是：\n保持主分支的更新，始终以最新的主分支为基础开发功能。 在开发过程中使用 rebase 而不是 merge 来同步主分支的更新，以保持提交历史的线性和简洁。 在功能开发完成后，确保功能分支与主分支同步，然后再推送并提交 Pull Request。 ","permalink":"http://119.91.218.8/zh/posts/git%E7%9A%84%E5%8D%8F%E4%BD%9C/","summary":"\u003cp\u003e在与他人协作开发一个功能时，使用 \u003ccode\u003egit rebase\u003c/code\u003e 可以保持提交历史的清洁和线性化。以下是一个推荐的 Git 工作流程，它结合了分支管理和 \u003ccode\u003erebase\u003c/code\u003e，适合在多人协作中保持历史干净：\u003c/p\u003e","title":"git的协作"},{"content":"ipmitool sdr elist 命令用于显示系统传感器的状态信息。\nSEL 和 SDR 是 IPMI（Intelligent Platform Management Interface）中的两个重要概念，它们分别表示系统事件日志和传感器数据记录。\n1. SEL (System Event Log) SEL 代表 System Event Log，即系统事件日志。它是一个记录了系统中关键事件的日志文件，通常包括硬件故障、警告、系统启动和关闭事件等。SEL 通常用于诊断和排除硬件问题。事件日志会记录事件的时间戳、事件类型、严重程度以及相关的详细信息。\n命令示例: 使用 ipmitool 查看 SEL： 1 sudo ipmitool sel list 这个命令会列出所有记录的系统事件，帮助管理员分析系统中的异常情况。 2. SDR (Sensor Data Record) SDR 代表 Sensor Data Record，即传感器数据记录。它是一个存储在系统中的数据库，包含了系统内所有传感器的详细信息，包括传感器的类型、名称、ID、状态、当前值、报警阈值等。SDR 是 IPMI 系统中用于监控和管理硬件状态的核心部分。\n命令示例: 使用 ipmitool 查看 SDR： 1 sudo ipmitool sdr 这个命令会列出系统中所有传感器的状态和读数，允许管理员监控系统的健康状态。 总结： SEL 用于记录和查看系统事件，帮助诊断和排除故障。 SDR 用于存储和管理传感器数据，实时监控系统的各项参数。 了解 SEL 和 SDR 是 IPMI 管理的重要部分，能够帮助你更好地维护和管理服务器的硬件状态。\n输出的每一行代表一个电源模块（PS1、PS2、PS3、PS4）的状态。以下是输出信息的含义：\nPS1 Status:\nC4h: 传感器ID，具体的数值因硬件而异。 ok: 状态正常。 10.92: 电压或类似的数值，这里通常表示与电源相关的数值。 Presence detected: 表示电源模块被检测到存在。 PS2 Status:\nC5h: 传感器ID。 ok: 状态正常。 10.91: 电压或类似的数值。 Presence detected, Failure detected: 表示电源模块被检测到存在，但也检测到故障。 PS3 Status:\nC6h: 传感器ID。 ok: 状态正常。 10.90: 电压或类似的数值。 Presence detected: 表示电源模块被检测到存在。 PS4 Status:\nC7h: 传感器ID。 ok: 状态正常。 10.89: 电压或类似的数值。 Presence detected: 表示电源模块被检测到存在。 关键点： Presence detected: 电源模块被检测到。 Failure detected: 仅在 PS2 中出现，表明这个电源模块存在某种故障。虽然状态显示为 ok，但这可能是因为故障并不影响系统的整体运行，但仍然值得进一步检查。 你可能需要检查 PS2 的具体状态，可能需要通过 ipmitool 获取更多详细信息或查看相关日志，确保电源模块在未来不会引发更严重的问题。\n","permalink":"http://119.91.218.8/zh/posts/%E7%94%B5%E6%BA%90%E6%95%85%E9%9A%9C%E6%9F%A5%E8%AF%A2%E6%8C%87%E4%BB%A4/","summary":"\u003cp\u003e\u003ccode\u003eipmitool sdr elist\u003c/code\u003e 命令用于显示系统传感器的状态信息。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eSEL\u003c/code\u003e 和 \u003ccode\u003eSDR\u003c/code\u003e 是 \u003ccode\u003eIPMI\u003c/code\u003e（Intelligent Platform Management Interface）中的两个重要概念，它们分别表示系统事件日志和传感器数据记录。\u003c/p\u003e","title":"电源故障查询指令"},{"content":"今天在尝试复现quip#的时候发现了问题，在进行setup install的时候发现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [1/3] /usr/local/cuda/bin/nvcc --generate-dependencies-with-compile --dependency-output /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o.d -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/torch/csrc/api/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/TH -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/THC -I/usr/local/cuda/include -I/home/ubuntu/miniconda3/envs/quant/include/python3.11 -c -c /home/ubuntu/data/exp/quip-sharp/quiptools/quiptools.cu -o /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ --expt-relaxed-constexpr --compiler-options \u0026#39;\u0026#39;\u0026#34;\u0026#39;\u0026#34;\u0026#39;-fPIC\u0026#39;\u0026#34;\u0026#39;\u0026#34;\u0026#39;\u0026#39; -O2 -g -Xcompiler -rdynamic -lineinfo -std=c++20 -DTORCH_API_INCLUDE_EXTENSION_H \u0026#39;-DPYBIND11_COMPILER_TYPE=\u0026#34;_gcc\u0026#34;\u0026#39; \u0026#39;-DPYBIND11_STDLIB=\u0026#34;_libstdcpp\u0026#34;\u0026#39; \u0026#39;-DPYBIND11_BUILD_ABI=\u0026#34;_cxxabi1011\u0026#34;\u0026#39; -DTORCH_EXTENSION_NAME=quiptools_cuda -D_GLIBCXX_USE_CXX11_ABI=0 -gencode=arch=compute_89,code=compute_89 -gencode=arch=compute_89,code=sm_89 FAILED: /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o /usr/local/cuda/bin/nvcc --generate-dependencies-with-compile --dependency-output /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o.d -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/torch/csrc/api/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/TH -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/THC -I/usr/local/cuda/include -I/home/ubuntu/miniconda3/envs/quant/include/python3.11 -c -c /home/ubuntu/data/exp/quip-sharp/quiptools/quiptools.cu -o /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ --expt-relaxed-constexpr --compiler-options \u0026#39;\u0026#39;\u0026#34;\u0026#39;\u0026#34;\u0026#39;-fPIC\u0026#39;\u0026#34;\u0026#39;\u0026#34;\u0026#39;\u0026#39; -O2 -g -Xcompiler -rdynamic -lineinfo -std=c++20 -DTORCH_API_INCLUDE_EXTENSION_H \u0026#39;-DPYBIND11_COMPILER_TYPE=\u0026#34;_gcc\u0026#34;\u0026#39; \u0026#39;-DPYBIND11_STDLIB=\u0026#34;_libstdcpp\u0026#34;\u0026#39; \u0026#39;-DPYBIND11_BUILD_ABI=\u0026#34;_cxxabi1011\u0026#34;\u0026#39; -DTORCH_EXTENSION_NAME=quiptools_cuda -D_GLIBCXX_USE_CXX11_ABI=0 -gencode=arch=compute_89,code=compute_89 -gencode=arch=compute_89,code=sm_89 /usr/include/x86_64-linux-gnu/bits/floatn-common.h(214): error: invalid combination of type specifiers typedef float _Float32; ^ /usr/include/x86_64-linux-gnu/bits/floatn-common.h(251): error: invalid combination of type specifiers typedef double _Float64; 事实上只要清理干净使用的gcc和g++版本\n1 2 3 4 5 6 7 8 9 10 11 12 ls /usr/bin/gcc* ls /usr/bin/g++* sudo apt remove gcc-10 gcc-13 g++-10 g++-13 # 通常ubuntu20.04使用9.4版本的gcc和g++ # 手动创建这些链接 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 60 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 60 # 设置对应版本 sudo update-alternatives --config gcc sudo update-alternatives --config g++ ","permalink":"http://119.91.218.8/zh/posts/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E7%BC%96%E8%AF%91pytorch-%E7%9A%84cuda%E6%8F%92%E4%BB%B6%E7%9A%84%E8%B8%A9%E5%9D%91%E8%BF%87%E7%A8%8B/","summary":"\u003cp\u003e今天在尝试复现quip#的时候发现了问题，在进行setup install的时候发现\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e 1\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 2\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 3\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 4\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 5\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 6\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 7\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 8\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e 9\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e10\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e11\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e12\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e13\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e14\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e15\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e16\n\u003c/span\u003e\u003cspan class=\"lnt\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e1/3\u003cspan class=\"o\"\u003e]\u003c/span\u003e /usr/local/cuda/bin/nvcc --generate-dependencies-with-compile --dependency-output /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o.d -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/torch/csrc/api/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/TH -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/THC -I/usr/local/cuda/include -I/home/ubuntu/miniconda3/envs/quant/include/python3.11 -c -c /home/ubuntu/data/exp/quip-sharp/quiptools/quiptools.cu -o /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ --expt-relaxed-constexpr --compiler-options \u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u0026#39;\u0026#34;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;-fPIC\u0026#39;\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u0026#39;\u0026#34;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e -O2 -g -Xcompiler -rdynamic -lineinfo -std\u003cspan class=\"o\"\u003e=\u003c/span\u003ec++20 -DTORCH_API_INCLUDE_EXTENSION_H \u003cspan class=\"s1\"\u003e\u0026#39;-DPYBIND11_COMPILER_TYPE=\u0026#34;_gcc\u0026#34;\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;-DPYBIND11_STDLIB=\u0026#34;_libstdcpp\u0026#34;\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;-DPYBIND11_BUILD_ABI=\u0026#34;_cxxabi1011\u0026#34;\u0026#39;\u003c/span\u003e -DTORCH_EXTENSION_NAME\u003cspan class=\"o\"\u003e=\u003c/span\u003equiptools_cuda -D_GLIBCXX_USE_CXX11_ABI\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e -gencode\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003earch\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecompute_89,code\u003cspan class=\"o\"\u003e=\u003c/span\u003ecompute_89 -gencode\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003earch\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecompute_89,code\u003cspan class=\"o\"\u003e=\u003c/span\u003esm_89\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eFAILED: /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/usr/local/cuda/bin/nvcc --generate-dependencies-with-compile --dependency-output /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o.d -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/torch/csrc/api/include -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/TH -I/home/ubuntu/miniconda3/envs/quant/lib/python3.11/site-packages/torch/include/THC -I/usr/local/cuda/include -I/home/ubuntu/miniconda3/envs/quant/include/python3.11 -c -c /home/ubuntu/data/exp/quip-sharp/quiptools/quiptools.cu -o /home/ubuntu/data/exp/quip-sharp/quiptools/build/temp.linux-x86_64-cpython-311/quiptools.o -D__CUDA_NO_HALF_OPERATORS__ -D__CUDA_NO_HALF_CONVERSIONS__ -D__CUDA_NO_BFLOAT16_CONVERSIONS__ -D__CUDA_NO_HALF2_OPERATORS__ --expt-relaxed-constexpr --compiler-options \u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u0026#39;\u0026#34;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;-fPIC\u0026#39;\u003c/span\u003e\u003cspan class=\"s2\"\u003e\u0026#34;\u0026#39;\u0026#34;\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e -O2 -g -Xcompiler -rdynamic -lineinfo -std\u003cspan class=\"o\"\u003e=\u003c/span\u003ec++20 -DTORCH_API_INCLUDE_EXTENSION_H \u003cspan class=\"s1\"\u003e\u0026#39;-DPYBIND11_COMPILER_TYPE=\u0026#34;_gcc\u0026#34;\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;-DPYBIND11_STDLIB=\u0026#34;_libstdcpp\u0026#34;\u0026#39;\u003c/span\u003e \u003cspan class=\"s1\"\u003e\u0026#39;-DPYBIND11_BUILD_ABI=\u0026#34;_cxxabi1011\u0026#34;\u0026#39;\u003c/span\u003e -DTORCH_EXTENSION_NAME\u003cspan class=\"o\"\u003e=\u003c/span\u003equiptools_cuda -D_GLIBCXX_USE_CXX11_ABI\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"m\"\u003e0\u003c/span\u003e -gencode\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003earch\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecompute_89,code\u003cspan class=\"o\"\u003e=\u003c/span\u003ecompute_89 -gencode\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"nv\"\u003earch\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003ecompute_89,code\u003cspan class=\"o\"\u003e=\u003c/span\u003esm_89\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/usr/include/x86_64-linux-gnu/bits/floatn-common.h\u003cspan class=\"o\"\u003e(\u003c/span\u003e214\u003cspan class=\"o\"\u003e)\u003c/span\u003e: error: invalid combination of \u003cspan class=\"nb\"\u003etype\u003c/span\u003e specifiers\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  typedef float _Float32\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                ^\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/usr/include/x86_64-linux-gnu/bits/floatn-common.h\u003cspan class=\"o\"\u003e(\u003c/span\u003e251\u003cspan class=\"o\"\u003e)\u003c/span\u003e: error: invalid combination of \u003cspan class=\"nb\"\u003etype\u003c/span\u003e specifiers\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  typedef double _Float64\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e事实上只要清理干净使用的gcc和g++版本\u003c/p\u003e","title":"记录一次编译pytorch 的cuda插件的踩坑过程"},{"content":"丢弃更改 1. 丢弃工作区的未暂存更改 如果你在工作区修改了文件但尚未暂存（使用 git add），可以使用以下命令将文件恢复到上一次提交时的状态：\n1 git checkout -- \u0026lt;file\u0026gt; 这个命令会丢弃指定文件的更改，恢复到上次提交的版本。\n如果想丢弃所有文件的更改，可以使用：\n1 git checkout -- . 2. 丢弃已暂存的更改 如果你已经使用 git add 将更改暂存，但还没有提交，可以使用以下命令将更改从暂存区移除，但保留在工作区中：\n1 git reset HEAD \u0026lt;file\u0026gt; 这样做会将文件从暂存区移除，但工作区中的更改仍然存在。\n如果想将所有已暂存的文件移除暂存区，可以使用：\n1 git reset HEAD . 3. 丢弃所有未提交的更改（包括工作区和暂存区） 如果你想要彻底丢弃所有未提交的更改（包括工作区和暂存区的更改），可以使用以下命令：\n1 git reset --hard 这个命令会将你的工作区和暂存区重置到上一次提交的状态，所有未提交的更改都会丢失。\n4. 丢弃已经提交的更改 如果你已经提交了更改，但想要撤销提交，可以使用以下命令：\n回滚到之前的提交但保留更改在工作区：\n1 git reset --soft \u0026lt;commit-hash\u0026gt; 这将把当前分支重置到指定的提交，但保留更改在暂存区。\n彻底丢弃提交后的更改：\n1 git reset --hard \u0026lt;commit-hash\u0026gt; 这个命令会将当前分支重置到指定的提交，工作区和暂存区的更改都会被丢弃。\n5. 丢弃特定提交的更改 如果你想撤销某个特定的提交，可以使用 git revert：\n1 git revert \u0026lt;commit-hash\u0026gt; 这个命令会生成一个新的提交来撤销指定的更改，而不会影响其他历史提交。\n使用这些命令时需要谨慎，特别是 git reset --hard，因为这会丢失所有未提交的更改，无法恢复。\n","permalink":"http://119.91.218.8/zh/posts/%E5%B8%B8%E7%94%A8git%E6%93%8D%E4%BD%9C/","summary":"\u003ch3 id=\"丢弃更改\"\u003e丢弃更改\u003c/h3\u003e\n\u003ch4 id=\"1-丢弃工作区的未暂存更改\"\u003e1. \u003cstrong\u003e丢弃工作区的未暂存更改\u003c/strong\u003e\u003c/h4\u003e\n\u003cp\u003e如果你在工作区修改了文件但尚未暂存（使用 \u003ccode\u003egit add\u003c/code\u003e），可以使用以下命令将文件恢复到上一次提交时的状态：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv class=\"chroma\"\u003e\n\u003ctable class=\"lntable\"\u003e\u003ctr\u003e\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode\u003e\u003cspan class=\"lnt\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd class=\"lntd\"\u003e\n\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit checkout -- \u0026lt;file\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e这个命令会丢弃指定文件的更改，恢复到上次提交的版本。\u003c/p\u003e","title":"常用git操作"},{"content":"2 背景 我们提供了一些关于现代硬件（GPU）上常见深度学习操作性能特性的背景信息，并描述了注意力机制的标准实现。\n2.1 硬件性能 我们主要关注GPU。其他硬件加速器的性能类似。\nGPU内存层次结构\nGPU的内存层次结构（图1左侧）包含多种不同大小和速度的内存，其中较小的内存速度更快。例如，A100 GPU具有40-80GB的高带宽内存（HBM），其带宽为1.5-2.0TB/s，并且每个108个流处理器（streaming multiprocessors）中的每个都具有192KB的片上SRAM，带宽估计为19TB/s左右。片上SRAM的速度比HBM快一个数量级，但其大小则小了许多数量级。随着计算速度相对于内存速度的提升，操作越来越受到内存（HBM）访问的瓶颈影响。因此，利用快速的SRAM变得更加重要。\n执行模型\nGPU拥有大量线程来执行一个操作（称为kernel）。每个kernel从HBM加载输入到寄存器和SRAM中，进行计算，然后将输出写入HBM。\n性能特性\n根据计算和内存访问的平衡，操作可以分为计算受限或内存受限。这通常通过算术强度来衡量，算术强度是每字节内存访问的算术操作数量。\n计算受限：操作的时间取决于算术操作的数量，而访问HBM的时间则要少得多。典型的例子包括具有大内维度的矩阵乘法和具有大量通道的卷积。\n内存受限：操作的时间取决于内存访问的数量，而计算所花费的时间则要少得多。例子包括大多数其他操作：元素级操作（例如，激活、dropout），以及归约操作（例如，求和、softmax、批量归一化、层归一化）。\n内核融合\n加速内存受限操作的最常见方法是内核融合：如果有多个操作应用于相同的输入，则输入可以从HBM中加载一次，而不是为每个操作多次加载。编译器可以自动融合许多元素级操作。然而，在模型训练的背景下，中间值仍需要写入HBM以供反向传播使用，从而降低了简单内核融合的效果。\n2.2 标准注意力机制实现 $$ S =QK^T\\in R^{N\\times N},\\quad P=softmax(S)\\in R^{N\\times N},\\quad O=PV\\in R^{N\\times N} $$ 其中 softmax 是按行应用【applied row-wise】的。\n标准的注意力机制实现将矩阵 S 和 P 物化【materialize】到高带宽内存（HBM），这需要 𝑂(𝑁²) 的内存。通常 𝑁 远大于 𝑑（例如，对于 GPT-2，𝑁 = 1024 而 𝑑 = 64）。我们在算法0中描述了标准注意力机制的实现。由于部分或大多数操作都是内存受限的（例如 softmax），大量的内存访问会导致较慢的实际运行时间。\n这个问题因应用于注意力矩阵的其他元素级操作而加剧，例如应用于 S 的掩码操作或应用于 P 的 dropout。因此，已有许多尝试将几个元素级操作融合在一起，例如将掩码与 softmax 融合。\n在第3.2节中，我们将展示标准注意力机制实现中高带宽内存的访问次数是序列长度 𝑁 的平方。同时，我们还将比较标准注意力机制与我们的方法（FlashAttention）的FLOPs数量和高带宽内存访问次数。\n算法0：标准注意力机制实现\n前提条件：HBM中的矩阵 $Q, K, V ∈ R^{N\\times d}$。\n从HBM按块加载 Q 和 K，计算 $S = QKᵀ$，并将 S 写入 HBM。 从HBM读取 S，计算$P = softmax(S)$，并将 P 写入 HBM。 从HBM按块加载 P 和 V，计算 $O = PV$，并将 O 写入 HBM。 返回 O。 3 FlashAttention: 算法、分析与扩展 我们展示了如何在减少HBM读取/写入次数的情况下计算精确的注意力，并且无需为反向传播存储大型中间矩阵。这产生了一种既节省内存又在实际运行时间上更快的注意力算法。我们分析了其IO复杂性，表明我们的方法相比于标准注意力机制需要更少的HBM访问次数。我们进一步展示了FlashAttention作为一个有用的基本模块可以扩展为处理块稀疏注意力。\n为了便于讲解，我们主要关注前向传播部分；附录B包含了反向传播的详细信息。\n3.1 一种使用分块和重计算的高效注意力算法 给定HBM中的输入 $Q, K, V \\in \\mathbb{R}^{N \\times d}$，我们的目标是计算注意力输出 $O \\in \\mathbb{R}^{N \\times d}$ 并将其写入HBM。我们的目标是减少HBM访问次数（到 $N$ 的亚二次方）。\n我们应用了两种已确立的技术（分块、重计算）来克服在 $N$ 的亚二次方HBM访问次数下计算精确注意力的技术挑战。我们在算法1中描述了这一过程。主要思路是将输入 $Q, K, V$ 分块，从慢速HBM加载到快速SRAM，然后根据这些块计算注意力输出。通过在累加之前按正确的归一化因子缩放每个块的输出，我们最终得到正确的结果。\n$$ m(x) := \\max_i x_i, \\quad f(x) := \\left[ \\exp(x_1 - m(x)), \\dots, \\exp(x_B - m(x)) \\right], \\quad \\ell(x) := \\sum_i f(x)_i, \\quad \\text{softmax}(x) := \\frac{f(x)}{\\ell(x)} $$$$ m(x) = m\\left(\\left[ x^{(1)}, x^{(2)} \\right]\\right) = \\max\\left(m(x^{(1)}), m(x^{(2)})\\right), \\quad f(x) = \\left[ \\exp(m(x^{(1)}) - m(x)) f(x^{(1)}), \\exp(m(x^{(2)}) - m(x)) f(x^{(2)}) \\right], $$$$ \\ell(x) = \\ell\\left(\\left[ x^{(1)}, x^{(2)} \\right]\\right) = \\exp(m(x^{(1)}) - m(x)) \\ell(x^{(1)}) + \\exp(m(x^{(2)}) - m(x)) \\ell(x^{(2)}), \\quad \\text{softmax}(x) = \\frac{f(x)}{\\ell(x)} $$ 因此，如果我们跟踪一些额外的统计数据（$m(x), \\ell(x)$），我们可以一次计算一个块的softmax值。我们将输入 $Q, K, V$ 分块（算法1第3行），计算softmax值及额外的统计数据（算法1第10行），并合并结果（算法1第12行）。\n重计算\n我们的目标之一是避免存储 $O(N^2)$ 个用于反向传播的中间值。反向传播通常需要矩阵 $S, P \\in \\mathbb{R}^{N \\times N}$ 来计算相对于 $Q, K, V$ 的梯度。然而，通过存储输出 $O$ 和softmax归一化统计数据（$m, \\ell$），我们可以在反向传播过程中从SRAM中的 $Q, K, V$ 块轻松重计算注意力矩阵 $S$ 和 $P$。这可以视为一种选择性梯度检查点策略。虽然梯度检查点策略已被建议用于减少所需的最大内存量，但所有已知的实现都不得不在速度和内存之间进行权衡。相比之下，即使有更多的FLOPs，我们的重计算由于减少了HBM访问次数而加快了反向传播过程。完整的反向传播描述见附录B。\n实现细节：内核融合\n分块使我们能够在一个CUDA内核中实现我们的算法，从HBM加载输入，执行所有计算步骤（矩阵乘法、softmax、可选的掩码和dropout、矩阵乘法），然后将结果写回HBM（掩码和dropout在附录B中）。这避免了反复从HBM读取和写入输入和输出。\n算法1：FlashAttention\n前提条件：HBM中的矩阵 $Q, K, V \\in \\mathbb{R}^{N \\times d}$，片上SRAM大小为 $M$。\n设置块大小 $B_c = \\left\\lceil \\frac{M}{4d} \\right\\rceil$, $B_r = min ( \\lceil \\frac{M}{4d} \\rceil ,d)$. 初始化 $O = (0)_{N \\times d} \\in \\mathbb{R}^{N \\times d}$, $\\ell = (0)_N \\in \\mathbb{R}^N$, $m = (-\\infty)_N \\in \\mathbb{R}^N$ 在HBM中。 将 $Q$ 分成 $T_r = \\left\\lceil \\frac{N}{B_r} \\right\\rceil$ 个块 $Q_1, \\dots, Q_{T_r}$ ，每个大小为 $B_r \\times d$；将 $K, V$ 分成 $T_c = \\left\\lceil \\frac{N}{B_c} \\right\\rceil$ 个块 $K_1, \\dots, K_{T_c}$ 和 $V_1, \\dots, V_{T_c}$ ，每个大小为 $B_c \\times d$。 将 $O$ 分成 $T_r$ 个块 $O_i, \\dots, O_{T_r}$ ，每个大小为 $B_r \\times d$；将 $\\ell$ 分成 $T_r$ 个块 $\\ell_i, \\dots, \\ell_{T_r}$ ，每个大小为 $B_r$；将 $m$ 分成 $T_r$ 个块 $m_1, \\dots, m_{T_r}$ ，每个大小为 $B_r$。 对于 $1 \\leq j \\leq T_c$： 从HBM加载 $K_j, V_j$ 到片上SRAM。 对于 $1 \\leq i \\leq T_r$： 从HBM加载 $Q_i, O_i, \\ell_i, m_i$ 到片上SRAM。 在片上计算 $S_{ij} = Q_i K_j^\\top \\in \\mathbb{R}^{B_r \\times B_c}$。 在片上计算 $\\tilde{m}{ij} = \\text{rowmax}(S{ij}) \\in \\mathbb{R}^{B_r}$，$\\tilde{P}{ij} = \\exp(S{ij} - \\tilde{m}{ij}) \\in \\mathbb{R}^{B_r \\times B_c}$（逐点计算），$\\tilde{\\ell}{ij} = \\text{rowsum}(\\tilde{P}_{ij}) \\in \\mathbb{R}^{B_r}$。 在片上计算 $m_{i}^{\\text{new}} = \\max(m_i, \\tilde{m}{ij}) \\in \\mathbb{R}^{B_r}$，$\\ell{i}^{\\text{new}} = \\exp(m_i - m_{i}^{\\text{new}})\\ell_i + \\exp(\\tilde{m}{ij} - m{i}^{\\text{new}})\\tilde{\\ell}_{ij} \\in \\mathbb{R}^{B_r}$。 写入$$O_i \\leftarrow \\text{diag}(\\ell_{i}^{\\text{new}})^{-1}\\left(\\text{diag}(\\ell_i)\\exp(m_i-m _{i}^{\\text{new}})O_i + \\exp(\\tilde{m}_{ij} - m_{i}^{\\text{new}})\\tilde{P}_{ij}V_j\\right)$$ 到HBM。 写入 $\\ell_i \\leftarrow \\ell_{i}^{\\text{new}}$，$m_i \\leftarrow m_{i}^{\\text{new}}$ 到HBM。 结束循环 结束循环 返回 $O$。 我们证明了FlashAttention的正确性、运行时间和内存需求（证明在附录C中）。\n定理1：算法1返回 $O = \\text{softmax}(QK^\\top)V$ ，具有 $\\mathcal{O}(N^2d)$ 的FLOPs，并且除了输入和输出之外仅需要 $\\mathcal{O}(N)$ 的额外内存。\n","permalink":"http://119.91.218.8/zh/posts/flashattention-fast-and-memory-efficient-exact-attention-with-io-awareness/","summary":"\u003ch2 id=\"2-背景\"\u003e2 背景\u003c/h2\u003e\n\u003cp\u003e我们提供了一些关于现代硬件（GPU）上常见深度学习操作性能特性的背景信息，并描述了注意力机制的标准实现。\u003c/p\u003e\n\u003ch3 id=\"21-硬件性能\"\u003e2.1 硬件性能\u003c/h3\u003e\n\u003cp\u003e我们主要关注GPU。其他硬件加速器的性能类似。\u003c/p\u003e","title":"FlashAttention Fast and Memory-Efficient Exact Attention with IO-Awareness"}]