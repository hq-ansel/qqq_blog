---
date: 2024-12-13T21:12:59+08:00
tags:
  - leetcode
  - hash
title: leetcode 49 字母异位词
share: true
canonicalURL: ""
keywords: 
description: 
series: 系列
lastmod: 
lang: cn
cover:
  image: 
author: qqq
dir: posts
math: "true"
---

## 前言
两个字符串互为字母异位词，当且仅当两个字符串包含的字母相同。同一组字母异位词中的字符串具备相同点，可以使用相同点作为一组字母异位词的标志，使用哈希表存储每一组字母异位词，哈希表的键为一组字母异位词的标志，哈希表的值为一组字母异位词列表。

遍历每个字符串，对于每个字符串，得到该字符串所在的一组字母异位词的标志，将当前字符串加入该组字母异位词的列表中。遍历全部字符串之后，哈希表中的每个键值对即为一组字母异位词。

以下的两种方法分别使用排序和计数作为哈希表的键。

## 方法一：排序
由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> mp;
        for (string& str: strs) {
            string key = str;
            sort(key.begin(), key.end());
            mp[key].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};
```

## 复杂度分析

时间复杂度：$O(nklogk)$，其中 $n$ 是 $strs$ 中的字符串的数量，$k$ 是 $strs$ 中的字符串的的最大长度。需要遍历 $n$ 个字符串，对于每个字符串，需要 $O(klogk)$ 的时间进行排序以及 $O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(nklogk)$。

空间复杂度：$O(nk)$，其中 $n$ 是 $strs$ 中的字符串的数量，$k$ 是 $strs$ 中的字符串的的最大长度。需要用哈希表存储全部字符串。

## 方法二：计数
由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。

由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。
```
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        // 自定义对 array<int, 26> 类型的哈希函数
        auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {
            return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {
                return (acc << 1) ^ fn(num);
            });
        };

        unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);
        for (string& str: strs) {
            array<int, 26> counts{};
            int length = str.length();
            for (int i = 0; i < length; ++i) {
                counts[str[i] - 'a'] ++;
            }
            mp[counts].emplace_back(str);
        }
        vector<vector<string>> ans;
        for (auto it = mp.begin(); it != mp.end(); ++it) {
            ans.emplace_back(it->second);
        }
        return ans;
    }
};

```
复杂度分析

时间复杂度：$O(n(k+∣Σ∣))$，其中 $n$ 是 $strs$ 中的字符串的数量，$k$ 是 $strs$ 中的字符串的的最大长度，$Σ$ 是字符集，在本题中字符集为所有小写字母，$∣Σ∣=26$。需要遍历 $n$ 个字符串，对于每个字符串，需要 $O(k)$ 的时间计算每个字母出现的次数，$O(∣Σ∣)$ 的时间生成哈希表的键，以及$O(1)$ 的时间更新哈希表，因此总时间复杂度是 $O(n(k+∣Σ∣))$。

空间复杂度：$O(n(k+∣Σ∣))$，其中 n 是 strs 中的字符串的数量，$k$ 是 $strs$ 中的字符串的最大长度，$Σ$ 是字符集，在本题中字符集为所有小写字母，$∣Σ∣=26$。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 $O(∣Σ∣)$，在渐进意义下小于 $O(n(k+∣Σ∣))$，可以忽略不计。


## 方法二中的位运算技巧


- 使用 `acc << 1 ^ fn(num)` 的技巧主要是通过 **左移** 和 **异或** 操作混合哈希值，达到 **增加哈希的分散性** 和 **减少哈希冲突** 的效果。
- **左移** 操作将哈希值向更高的位扩展，而 **异或** 操作则有效地将新计算的哈希值混合到现有的累计哈希值中。
- 这种方法特别适用于 **哈希函数** 的设计，能够提高哈希表的性能，尤其是在数据量较大的情况下，能够减少碰撞并确保哈希结果的均匀分布。


### 1. **左移操作（`<<`）**

左移操作符 `<<` 是一个位运算操作符，它将数值的二进制位向左移动一定的位数。例如：

- `a << 1` 表示将 `a` 的二进制表示向左移动一位，相当于把所有的二进制位向左移动，并在右边填充 `0`。
    
    **例子：**
    
    ```cpp
    5  (二进制表示： 0000 0101)
    5 << 1  (结果： 0000 1010，即 10)
    ```
    
    可以看到，左移一位，相当于将数字乘以 2。
    

在哈希函数中，左移操作通常用于**扩展哈希值**，将当前计算的哈希值移到更高的位上，准备好与下一个元素的哈希值进行混合。

### 2. **异或操作（`^`）**

异或操作符 `^` 是一个按位操作符，它对两个二进制数的每一位执行 **异或** 操作。异或的规则如下：

- `0 ^ 0 = 0`
- `0 ^ 1 = 1`
- `1 ^ 0 = 1`
- `1 ^ 1 = 0`

异或有以下几个重要的特点：

- **自反性**：`a ^ a = 0`，即任何数和它自己异或，结果为 0。
- **交换性和结合性**：`a ^ b = b ^ a`，并且 `(a ^ b) ^ c = a ^ (b ^ c)`。
- **用于混合信息**：通过异或不同的值，可以有效地混合和传播信息。

在哈希函数中，异或操作通常用来**混合不同元素的哈希值**，将每个元素的哈希信息合并到一起，避免单独使用某一部分信息导致哈希冲突。

### 3. **结合运算：`acc << 1 ^ fn(num)`**

在这段代码中，`acc << 1 ^ fn(num)` 是利用左移和异或的结合，来**混合哈希信息**并防止哈希冲突。让我们逐步解析这一操作的效果：

- **左移 `acc << 1`**：这一步将现有的哈希值 `acc` 向左移动一位，相当于将 `acc` 的所有位数扩大，并将空余的低位填充为 0。这步操作确保了新的哈希值包含了以前计算的结果，并为新元素留出空间。
    
- **异或 `^ fn(num)`**：接下来，通过异或操作将 `fn(num)` 的哈希值（即当前元素的哈希）与 `acc << 1` 结合。异或操作的作用是将 `acc` 和 `num` 的哈希值混合在一起。异或操作会根据 `fn(num)` 的值修改 `acc` 的高位，确保每个新元素的哈希信息都会影响到整个累计值。
    

#### 为什么使用这个技巧？

1. **提高哈希的分散性**：
    
    - 左移操作使得原有的哈希值向高位传播，这样新的哈希值不仅仅依赖于低位的信息。
    - 异或操作则将新计算的哈希值 `fn(num)` 与现有的累计值 `acc` 混合，进一步将哈希值中的位分散，避免高位的某些位在哈希表中容易重复。
2. **减少哈希冲突**：
    
    - 哈希冲突通常发生在不同的数据项经过哈希计算后得到了相同的哈希值。通过左移和异或的结合，我们在每次计算哈希值时都充分考虑了之前的计算结果，确保不同元素的哈希值差异被最大化，减少冲突的发生。
    - 具体来说，异或的作用在于将不同元素的哈希值在各个位上混合，尤其是对于大型数据集来说，这种操作能显著减少碰撞的机会。
3. **增强哈希的随机性**：
    
    - 异或操作和左移操作会使哈希结果更加随机，不容易预测。这对于哈希算法来说至关重要，因为哈希值的随机性直接影响到哈希表的性能。良好的哈希函数能够确保元素均匀地分布在哈希表中，从而避免不必要的碰撞。

### 4. **为什么采用 `acc << 1 ^ fn(num)` 组合？**

- **左移1位**：为了扩大累计值 `acc` 的范围，使其与新值（`fn(num)`）合并时可以在更高的位上进行混合。这种方法比简单地直接加法要更加有效，因为它能够将 `acc` 的信息向更高的位数扩展。
    
- **异或（`^`）**：异或操作用于将新元素的哈希值与现有的累计哈希值混合在一起。由于异或具有交换性和结合性，这种操作非常适合用来混合多个哈希值，确保新值的每一位都能影响到最终的累计哈希结果。
    

这种组合通常用于 **字符串哈希**、**整数哈希** 等算法中，尤其是当数据量较大时，能够显著提高哈希函数的质量和效率。

### 5. **具体示例**

假设我们有一个包含三个整数的数组 `[1, 2, 3]`，我们对每个整数分别进行哈希计算并将其累加起来。假设 `fn(num)` 就是对整数 `num` 调用 `hash<int>`。

1. 初始时，`acc = 0`。
2. 对第一个元素 `1`：
    - `acc << 1` 结果为 `0 << 1 = 0`，然后 `acc = 0 ^ fn(1)`（假设 `fn(1)` 返回 1）。
    - `acc = 0 ^ 1 = 1`。
3. 对第二个元素 `2`：
    - `acc << 1` 结果为 `1 << 1 = 2`，然后 `acc = 2 ^ fn(2)`（假设 `fn(2)` 返回 2）。
    - `acc = 2 ^ 2 = 0`。
4. 对第三个元素 `3`：
    - `acc << 1` 结果为 `0 << 1 = 0`，然后 `acc = 0 ^ fn(3)`（假设 `fn(3)` 返回 3）。
    - `acc = 0 ^ 3 = 3`。

最终，得到的哈希值是 3，表示整个数组的哈希值。

