---
date: 2024-12-23T19:12:55+08:00
tags:
  - leetcode
title: 单调栈与单调队列
share: true
canonicalURL: ""
keywords: 
description: 
series: 系列
lastmod: 
lang: cn
cover:
  image: 
author: qqq
dir: posts
math: "true"
---
# 单调栈
单调栈是一种特殊的栈数据结构，其特点是栈内的元素按照某种单调性排列，通常用于解决需要快速找到数组中某些元素相对大小关系的问题，例如**下一个更大元素**或**下一个更小元素**。

### 特点

1. **单调递增栈**：栈内元素从栈底到栈顶单调递增。当需要找到下一个更大元素时，可以使用这种栈。
2. **单调递减栈**：栈内元素从栈底到栈顶单调递减。当需要找到下一个更小元素时，可以使用这种栈。

### 工作原理

- **逐个遍历数组**：将元素与栈顶元素比较，根据单调性的要求决定是否弹栈或入栈。
- **保持栈的单调性**：
    - 如果新元素破坏了栈的单调性（例如，递增栈中出现比栈顶大的元素），就不断弹栈，直到栈重新满足单调性。
    - 新元素入栈，继续处理下一个元素。
- **处理栈顶元素的含义**：栈中的元素可以表示还未找到满足条件（更大或更小）的元素的索引。

### 示例：找下一个更大元素

假设有一个数组 `nums`，我们希望找到每个元素右侧第一个比它大的值的位置。

#### 代码实现

```python
def nextGreaterElement(nums):
    stack = []  # 存储数组的索引
    result = [-1] * len(nums)  # 初始化结果数组

    for i in range(len(nums)):
        # 当栈不为空且当前元素比栈顶索引对应的值大
        while stack and nums[i] > nums[stack[-1]]:
            idx = stack.pop()
            result[idx] = nums[i]  # 更新结果数组，找到下一个更大元素
        stack.append(i)  # 当前元素索引入栈

    return result

# 测试
nums = [2, 1, 5, 3, 6]
print(nextGreaterElement(nums))  # 输出 [5, 5, 6, 6, -1]
```

### 时间复杂度

- 遍历数组的每个元素一次，时间复杂度为 O(n)。
- 每个元素最多入栈和出栈一次，因此总的栈操作复杂度为 O(n)。
- 总时间复杂度为 O(n。

### 应用场景

1. **找下一个更大或更小的元素**：用于解决单调栈最经典的问题。
2. **直方图中的最大矩形面积**：通过单调栈找到每个柱子的左右边界。
3. **接雨水问题**：利用单调栈计算高度差。
4. **滑动窗口问题**：结合单调队列解决区间内的最值问题。

# 单调队列

**单调队列**是一种特殊的队列数据结构，能够在保持队列基本操作的同时，维护队列中的元素按照某种单调性排列。这种结构常用于在滑动窗口或连续区间中快速找到最大值或最小值。

---

### **特点**
1. **单调递增队列**：
   - 队列中的元素从队首到队尾按值递增。
   - 队首存储当前窗口的最小值。
2. **单调递减队列**：
   - 队列中的元素从队首到队尾按值递减。
   - 队首存储当前窗口的最大值。

---

### **操作原理**
1. **插入新元素**：
   - 在队尾插入新元素时，删除队列尾部所有比当前元素更小（或更大，取决于单调性）的元素，确保队列的单调性。
   - 插入操作需要维护队列的单调性，因此可以通过删除尾部多余的元素来完成。
   
2. **移出窗口元素**：
   - 当滑动窗口右移时，检查队首元素是否已经超出窗口范围。如果是，则将其从队首移出。

3. **查询最值**：
   - 当前窗口的最大值或最小值总是存储在队首，直接返回即可。

---

### **使用场景**
单调队列的经典应用是在一个滑动窗口中找到最大值或最小值。例如：
- 滑动窗口最大值
- 滑动窗口最小值
- 连续区间的最优值问题

---

### **示例：滑动窗口最大值**
假设我们有一个数组 `nums` 和一个滑动窗口大小 `k`，我们希望找到每个窗口的最大值。

#### **代码实现**
```python
from collections import deque

def maxSlidingWindow(nums, k):
    dq = deque()  # 单调递减队列，存储索引
    result = []

    for i in range(len(nums)):
        # 移除窗口外的元素（索引过期）
        if dq and dq[0] < i - k + 1:
            dq.popleft()

        # 保持单调递减，移除队列尾部比当前元素小的元素
        while dq and nums[dq[-1]] < nums[i]:
            dq.pop()

        # 当前元素索引入队
        dq.append(i)

        # 当窗口形成时，记录当前窗口的最大值
        if i >= k - 1:
            result.append(nums[dq[0]])

    return result

# 测试
nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
print(maxSlidingWindow(nums, k))  # 输出 [3, 3, 5, 5, 6, 7]
```

---

### **时间复杂度**
1. **遍历数组**：每个元素仅入队和出队一次，因此时间复杂度为 \(O(n)\)。
2. **总时间复杂度**： \(O(n)\)。

---



